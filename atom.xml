<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chancerain</title>
  
  <subtitle>小而美的Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-25T13:45:49.651Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chancerain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04 Express路由</title>
    <link href="http://example.com/2022/02/25/04-Express%E8%B7%AF%E7%94%B1/"/>
    <id>http://example.com/2022/02/25/04-Express%E8%B7%AF%E7%94%B1/</id>
    <published>2022-02-25T13:45:40.000Z</published>
    <updated>2022-02-25T13:45:49.651Z</updated>
    
    
    
    
    <category term="Node.js" scheme="http://example.com/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Node.js" scheme="http://example.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>03 Express的基本使用</title>
    <link href="http://example.com/2022/02/25/03-Express%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/02/25/03-Express%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-25T13:20:05.000Z</published>
    <updated>2022-02-25T13:44:45.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i express@4.17.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="创建基本的-Web-服务器"><a href="#创建基本的-Web-服务器" class="headerlink" title="创建基本的 Web 服务器"></a>创建基本的 Web 服务器</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//导入express</span><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token comment">//创建web服务器</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//调用 app.listen（端口号，启动成功后的回调函数），启动服务器</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'express server running at http://127.0.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="监听-GET-请求"><a href="#监听-GET-请求" class="headerlink" title="监听 GET 请求"></a>监听 GET 请求</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'请求url'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//req:请求对象（包含了与请求相关的属性和方法）</span><span class="token comment">//res:响应对象（包含了与请求相关的属性和方法）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="监听-POST-请求"><a href="#监听-POST-请求" class="headerlink" title="监听 POST 请求"></a>监听 POST 请求</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'请求url'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//req:请求对象（包含了与请求相关的属性和方法）</span><span class="token comment">//res:响应对象（包含了与请求相关的属性和方法）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="把内容响应给客户端"><a href="#把内容响应给客户端" class="headerlink" title="把内容响应给客户端"></a>把内容响应给客户端</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'请求成功'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="获取-URL-中携带的查询参数"><a href="#获取-URL-中携带的查询参数" class="headerlink" title="获取 URL 中携带的查询参数"></a>获取 URL 中携带的查询参数</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">//req.query默认是一个空对象</span>        <span class="token comment">//客户端使用 ?name=zs&amp;age=20 这种查询字符串形式。发送到服务器的参数</span>        <span class="token comment">//req.query.name   req.query.age</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>query<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获取-URL-中的动态参数"><a href="#获取-URL-中的动态参数" class="headerlink" title="获取 URL 中的动态参数"></a>获取 URL 中的动态参数</h2><p>通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/user/:id'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">//req.params是一个空对象</span>  <span class="token comment">//里面存着:动态匹配到的参数值</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>params<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=</summary>
      
    
    
    
    <category term="Node.js" scheme="http://example.com/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Node.js" scheme="http://example.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>02 模块化</title>
    <link href="http://example.com/2022/02/25/02-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://example.com/2022/02/25/02-%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2022-02-25T12:50:10.000Z</published>
    <updated>2022-02-25T13:18:20.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化的基本概念"><a href="#模块化的基本概念" class="headerlink" title="模块化的基本概念"></a>模块化的基本概念</h2><p>编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。 </p><p>把代码进行模块化拆分的好处： </p><ol><li>提高了代码的复用性</li><li>提高了代码的可维护性</li><li>可以实现按需加载</li></ol><h2 id="Node-js-中的模块化"><a href="#Node-js-中的模块化" class="headerlink" title="Node.js 中的模块化"></a>Node.js 中的模块化</h2><h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><p>Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是： </p><ol><li>内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）</li><li>自定义模块（用户创建的每个 .js 文件，都是自定义模块） </li><li>第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）</li></ol><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//加载内置的fs模块</span><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token comment">//加载用户的自定义模块</span><span class="token keyword">const</span> custom <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./custom.js'</span><span class="token punctuation">)</span><span class="token comment">//加载第三方模块</span><span class="token keyword">const</span> moment <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'moment'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><h4 id="什么是模块作用域"><a href="#什么是模块作用域" class="headerlink" title="什么是模块作用域"></a>什么是模块作用域</h4><p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块 作用域。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/e7e08e4c17970f0c.png"></p><h4 id="模块作用域的好处"><a href="#模块作用域的好处" class="headerlink" title="模块作用域的好处"></a>模块作用域的好处</h4><p>防止了全局变量污染的问题</p><h3 id="向外共享模块作用域中的成员"><a href="#向外共享模块作用域中的成员" class="headerlink" title="向外共享模块作用域中的成员"></a>向外共享模块作用域中的成员</h3><h4 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h4><p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息</p><h4 id="module-exports-对象"><a href="#module-exports-对象" class="headerlink" title="module.exports 对象"></a>module.exports 对象</h4><p>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。 外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象</p><h4 id="共享成员时的注意点"><a href="#共享成员时的注意点" class="headerlink" title="共享成员时的注意点"></a>共享成员时的注意点</h4><p>使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/6dca115ee98dabcc.png"></p><h4 id="exports-对象"><a href="#exports-对象" class="headerlink" title="exports 对象"></a>exports 对象</h4><p>由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况 下，exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。</p><h3 id="Node-js-中的模块化规范"><a href="#Node-js-中的模块化规范" class="headerlink" title="Node.js 中的模块化规范"></a>Node.js 中的模块化规范</h3><p>CommonJS 规定： </p><ol><li>每个模块内部，module 变量代表当前模块。</li><li>module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</li><li>加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块</li></ol><h2 id="npm与包"><a href="#npm与包" class="headerlink" title="npm与包"></a>npm与包</h2><h3 id="初次装包后多了哪些文件"><a href="#初次装包后多了哪些文件" class="headerlink" title="初次装包后多了哪些文件"></a>初次装包后多了哪些文件</h3><ul><li>node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 </li><li>package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。</li></ul><h3 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h3><p>npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置 信息。例如： </p><ul><li>项目的名称、版本号、描述等</li><li>项目中都用到了哪些包</li><li>哪些包只在开发期间会用到</li><li>那些包在开发和部署时都需要用到</li></ul><h4 id="dependencies-节点"><a href="#dependencies-节点" class="headerlink" title="dependencies 节点"></a>dependencies 节点</h4><p>package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/7a7aeb9f48fe5528.png"></p><h4 id="devDependencies-节点"><a href="#devDependencies-节点" class="headerlink" title="devDependencies 节点"></a>devDependencies 节点</h4><p>如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。 </p><p>与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i 包名 -Dnpm install 包名 --save-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h3><h4 id="项目包"><a href="#项目包" class="headerlink" title="项目包"></a>项目包</h4><p>那些被安装到项目的 node_modules 目录中的包，都是项目包。 </p><p>项目包又分为两类，分别是：</p><ul><li>开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）</li><li>核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i 包名 -D#开发依赖包npm i 包名#核型依赖包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="全局包"><a href="#全局包" class="headerlink" title="全局包"></a>全局包</h4><p>在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。 </p><p>全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i 包名 -gnpm uninstall 包名 -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</li><li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</li></ol><h3 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h3><ul><li>包必须以单独的目录而存在</li><li>包的顶级目录下要必须包含 package.json 这个包管理配置文件</li><li>package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模块化的基本概念&quot;&gt;&lt;a href=&quot;#模块化的基本概念&quot; class=&quot;headerlink&quot; title=&quot;模块化的基本概念&quot;&gt;&lt;/a&gt;模块化的基本概念&lt;/h2&gt;&lt;p&gt;编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。 &lt;/p</summary>
      
    
    
    
    <category term="Node.js" scheme="http://example.com/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Node.js" scheme="http://example.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>07 定位</title>
    <link href="http://example.com/2022/02/25/07-%E5%AE%9A%E4%BD%8D/"/>
    <id>http://example.com/2022/02/25/07-%E5%AE%9A%E4%BD%8D/</id>
    <published>2022-02-25T11:47:02.000Z</published>
    <updated>2022-02-25T12:28:37.705Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  &lt;!-- 绝对定位 --><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  &lt;!-- 相对定位 --><span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>     &lt;!-- 固定定位 --><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>让元素相对于自己原来的位置，进行位置调整（可用于盒子的位置微调）。</p><h3 id="相对定位不脱标"><a href="#相对定位不脱标" class="headerlink" title="相对定位不脱标"></a>相对定位不脱标</h3><p><strong>相对定位</strong>：不脱标，老家留坑，<strong>别人不会把它的位置挤走</strong>。</p><p>也就是说，相对定位的真实位置还在老家，只不过影子出去了，可以到处飘。</p><h3 id="相对定位的用途"><a href="#相对定位的用途" class="headerlink" title="相对定位的用途"></a>相对定位的用途</h3><ul><li>微调元素</li><li>做绝对定位的参考，子绝父相</li></ul><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p><strong>绝对定位的盒子脱离了标准文档流。</strong></p><h3 id="绝对定位的参考点（重要）"><a href="#绝对定位的参考点（重要）" class="headerlink" title="绝对定位的参考点（重要）"></a>绝对定位的参考点（重要）</h3><ol><li>如果用<strong>top描述</strong>，那么参考点就是<strong>页面的左上角</strong>，而不是浏览器的左上角：</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180115_2120.png" alt="img"></p><ol start="2"><li>如果用<strong>bottom描述</strong>，那么参考点就是<strong>浏览器首屏窗口尺寸</strong>（好好理解“首屏”二字），对应的页面的左下角：</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180115_2121.png" alt="img"></p><h3 id="以盒子为参考点"><a href="#以盒子为参考点" class="headerlink" title="以盒子为参考点"></a>以盒子为参考点</h3><p>一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180115_2210.png" alt="img"></p><h3 id="让绝对定位中的盒子在父亲里居中"><a href="#让绝对定位中的盒子在父亲里居中" class="headerlink" title="让绝对定位中的盒子在父亲里居中"></a>让绝对定位中的盒子在父亲里居中</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 60px<span class="token punctuation">;</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  绝对定位的盒子<span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>           首先，让左边线居中<span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token property">margin-left</span><span class="token punctuation">:</span> -300px<span class="token punctuation">;</span>  然后，向左移动宽度（600px）的一半<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><p>就是相对浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。</p><h2 id="z-index属性"><a href="#z-index属性" class="headerlink" title="z-index属性"></a>z-index属性</h2><p><strong>z-index</strong>属性：表示谁压着谁。数值大的压盖住数值小的。</p><p>有如下特性：</p><p>（1）属性值大的位于上层，属性值小的位于下层。</p><p>（2）z-index值没有单位，就是一个正整数。默认的z-index值是0。</p><p>（3）如果大家都没有z-index值，或者z-index值一样，那么在HTML代码里写在后面，谁就在上面能压住别人。定位了的元素，永远能够压住没有定位的元素。</p><p>（4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。<strong>而浮动的元素不能用</strong>。</p><p>（5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-css&quot; data-language=&quot;css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token property&quot;&gt;position&lt;/span&gt;&lt;span clas</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>06 浮动</title>
    <link href="http://example.com/2022/02/25/06%20%E6%B5%AE%E5%8A%A8/"/>
    <id>http://example.com/2022/02/25/06%20%E6%B5%AE%E5%8A%A8/</id>
    <published>2022-02-25T11:16:14.000Z</published>
    <updated>2022-02-25T11:46:46.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h2><p>宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作，是个“流”，必须从上而下，像“织毛衣”。而设计软件，想往哪里画个东西，都能画。</p><h3 id="标准文档流的特性"><a href="#标准文档流的特性" class="headerlink" title="标准文档流的特性"></a>标准文档流的特性</h3><ol><li><strong>空白折叠现象</strong></li><li><strong>高矮不齐，底边对齐</strong></li><li><strong>自动换行，一行写不满，换行写</strong></li></ol><h3 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h3><p><strong>行内元素和块级元素的区别：</strong>（非常重要）</p><p>行内元素：</p><ul><li>与其他行内元素并排；</li><li>不能设置宽、高。默认的宽度，就是文字的宽度。</li></ul><p>块级元素：</p><ul><li>霸占一行，不能与其他任何元素并列；</li><li>能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。</li></ul><p><strong>行内元素和块级元素的分类：</strong></p><p>在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。</p><p>从HTML的角度来讲，标签分为：</p><ul><li>文本级标签：p、span、a、b、i、u、em。</li><li>容器级标签：div、h系列、li、dt、dd。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170729_1545.png" alt="img"></p><p>css中一共有三种手段，使一个元素脱离标准文档流：</p><ul><li>（1）浮动</li><li>（2）绝对定位</li><li>（3）固定定位</li></ul><h2 id="浮动的性质"><a href="#浮动的性质" class="headerlink" title="浮动的性质"></a>浮动的性质</h2><h3 id="浮动的元素脱标"><a href="#浮动的元素脱标" class="headerlink" title="浮动的元素脱标"></a>浮动的元素脱标</h3><p><strong>一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。</strong>所有标签，浮动之后，已经不区分行内、块级了</p><h3 id="浮动的元素互相贴靠"><a href="#浮动的元素互相贴靠" class="headerlink" title="浮动的元素互相贴靠"></a>浮动的元素互相贴靠</h3><h3 id="浮动的元素有“字围”效果"><a href="#浮动的元素有“字围”效果" class="headerlink" title="浮动的元素有“字围”效果"></a>浮动的元素有“字围”效果</h3><p><strong>标准流中的文字不会被浮动的盒子遮挡住</strong>。（文字就像水一样）</p><h3 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h3><p>一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）</p><h2 id="浮动的清除"><a href="#浮动的清除" class="headerlink" title="浮动的清除"></a>浮动的清除</h2><h3 id="给浮动元素的祖先元素加高度"><a href="#给浮动元素的祖先元素加高度" class="headerlink" title="给浮动元素的祖先元素加高度"></a>给浮动元素的祖先元素加高度</h3><p><strong>如果一个元素要浮动，那么它的祖先元素一定要有高度。</strong></p><p><strong>有高度的盒子，才能关住浮动</strong>。</p><h3 id="clear-both"><a href="#clear-both" class="headerlink" title="clear:both"></a>clear:both</h3><p>clear就是清除，both指的是左浮动、右浮动都要清除。<code>clear:both</code>的意思就是：<strong>不允许左侧和右侧有浮动对象。</strong></p><p>这种方法有一个非常大的、致命的问题，<strong>它所在的标签，margin属性失效了</strong>。</p><h3 id="隔墙法"><a href="#隔墙法" class="headerlink" title="隔墙法"></a>隔墙法</h3><p>上面这个例子中，为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置<code>clear: both;</code>属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果（曲线救国）。这便是隔墙法。</p><h3 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow:hidden"></a>overflow:hidden</h3><p><code>overflow:hidden;</code>的本意是清除溢出到盒子外面的文字。但是，前端开发工程师发现了，它能做偏方。如下：</p><p>一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上<code>overflow:hidden</code>; 那么，父亲就能被儿子撑出高了。这是一个偏方。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170804_1920.png" alt="img"></p><h2 id="margin相关"><a href="#margin相关" class="headerlink" title="margin相关"></a>margin相关</h2><h3 id="margin塌陷-x2F-margin重叠"><a href="#margin塌陷-x2F-margin重叠" class="headerlink" title="margin塌陷&#x2F;margin重叠"></a>margin塌陷&#x2F;margin重叠</h3><p><strong>标准文档流中，竖直方向的margin不叠加，取</strong>较大的值**作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170805_0904.png" alt="img"></p><p>如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有塌陷现象的。</p><h3 id="盒子居中margin-0-auto"><a href="#盒子居中margin-0-auto" class="headerlink" title="盒子居中margin:0 auto;"></a>盒子居中<code>margin:0 auto;</code></h3><ul><li>只有标准流的盒子，才能使用<code>margin:0 auto;</code>居中。也就是说，当一个盒子浮动了、绝对定位了、固定定位了，都不能使用margin:0 auto;</li><li>使用<code>margin:0 auto;</code>的盒子，必须有width，有明确的width。（可以这样理解，如果没有明确的witdh，那么它的witdh就是霸占整行，没有意义）</li><li><code>margin:0 auto;</code>是让盒子居中，不是让盒子里的文本居中。文本的居中，要使用<code>text-align:center;</code></li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">margin</span><span class="token punctuation">:</span>0 auto<span class="token punctuation">;</span>    //让这个div自己在大容器中的水平方向上居中。<span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  //让这个div内部的文本居中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="善于使用父亲的padding，而不是儿子的margin"><a href="#善于使用父亲的padding，而不是儿子的margin" class="headerlink" title="善于使用父亲的padding，而不是儿子的margin"></a>善于使用父亲的padding，而不是儿子的margin</h3><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标准文档流&quot;&gt;&lt;a href=&quot;#标准文档流&quot; class=&quot;headerlink&quot; title=&quot;标准文档流&quot;&gt;&lt;/a&gt;标准文档流&lt;/h2&gt;&lt;p&gt;宏观地讲，我们的web页面和photoshop等设计软件有本质的区别：web页面的制作，是个“流”，必须从上而下，像</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>05 CSS盒子模型</title>
    <link href="http://example.com/2022/02/25/05-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/02/25/05-CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-02-25T05:49:07.000Z</published>
    <updated>2022-02-25T11:15:44.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="盒子中的区域"><a href="#盒子中的区域" class="headerlink" title="盒子中的区域"></a>盒子中的区域</h3><p>一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170727_2326.png" alt="img"></p><h2 id="标准盒模型和IE盒模型"><a href="#标准盒模型和IE盒模型" class="headerlink" title="标准盒模型和IE盒模型"></a>标准盒模型和IE盒模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt="img"></p><p>CSS盒模型和IE盒模型的区别：</p><ul><li>在 <strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li></ul><h2 id="认识padding"><a href="#认识padding" class="headerlink" title="认识padding"></a>认识padding</h2><h3 id="padding区域也有颜色"><a href="#padding区域也有颜色" class="headerlink" title="padding区域也有颜色"></a>padding区域也有颜色</h3><p>padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充<strong>所有border以内的区域。</strong></p><h2 id="认识border"><a href="#认识border" class="headerlink" title="认识border"></a>认识border</h2><p>border就是边框。边框有三个要素：像素（粗细）、线型、颜色。</p><h3 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a>border-style</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170728_1435.png" alt="img"></p><h2 id="利用-border-属性画一个三角形"><a href="#利用-border-属性画一个三角形" class="headerlink" title="利用 border 属性画一个三角形"></a>利用 border 属性画一个三角形</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.div1</span><span class="token punctuation">&#123;</span><span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span><span class="token property">border-top</span><span class="token punctuation">:</span> 30px solid red<span class="token punctuation">;</span><span class="token comment">/* 通过改变 border-left 和 border-right 中的像素值，来改变三角形的形状 */</span><span class="token property">border-left</span><span class="token punctuation">:</span> 20px solid transparent<span class="token punctuation">;</span><span class="token property">border-right</span><span class="token punctuation">:</span> 20px solid transparent<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;盒子模型&quot;&gt;&lt;a href=&quot;#盒子模型&quot; class=&quot;headerlink&quot; title=&quot;盒子模型&quot;&gt;&lt;/a&gt;盒子模型&lt;/h2&gt;&lt;h3 id=&quot;盒子中的区域&quot;&gt;&lt;a href=&quot;#盒子中的区域&quot; class=&quot;headerlink&quot; title=&quot;盒子中的区</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>04 CSS样式表的继承性和层叠性</title>
    <link href="http://example.com/2022/02/25/04-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7/"/>
    <id>http://example.com/2022/02/25/04-CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7/</id>
    <published>2022-02-25T05:34:25.000Z</published>
    <updated>2022-02-25T05:48:48.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS的继承性"><a href="#CSS的继承性" class="headerlink" title="CSS的继承性"></a>CSS的继承性</h2><blockquote><p>继承性是从自己开始，直到最小的元素。</p><ul><li>关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。</li><li>关于盒子、定位、布局的属性，都不能继承。</li></ul></blockquote><h2 id="CSS的层叠性"><a href="#CSS的层叠性" class="headerlink" title="CSS的层叠性"></a>CSS的层叠性</h2><h3 id="层叠性：计算权重"><a href="#层叠性：计算权重" class="headerlink" title="层叠性：计算权重"></a>层叠性：计算权重</h3><p>当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：</p><ul><li>id 选择器</li><li>类选择器、属性选择器、伪类选择器</li><li>标签选择器、伪元素选择器</li></ul><p>因为对于相同方式的样式表，其选择器排序的优先级为：ID选择器 &gt; 类选择器 &gt; 标签选择器</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20170727_2050.png" alt="img"></p><h3 id="CSS样式表的冲突的总结"><a href="#CSS样式表的冲突的总结" class="headerlink" title="CSS样式表的冲突的总结"></a>CSS样式表的冲突的总结</h3><ul><li>1、对于相同的选择器（比如同样都是类选择器），其样式表排序：行级样式 &gt; 内嵌样式表 &gt; 外部样式表（就近原则）</li><li>2、对于相同类型的样式表（比如同样都是内部样式表），其选择器排序：ID选择器 &gt; 类选择器 &gt; 标签选择器</li><li>3、外部样式表的ID选择器 &gt; 内嵌样式表的标签选择器</li></ul><h2 id="权重问题深入"><a href="#权重问题深入" class="headerlink" title="权重问题深入"></a>权重问题深入</h2><h3 id="同一个标签，携带了多个类名，有冲突："><a href="#同一个标签，携带了多个类名，有冲突：" class="headerlink" title="同一个标签，携带了多个类名，有冲突："></a>同一个标签，携带了多个类名，有冲突：</h3><p>这里需要补充两种冲突的情况：</p><ul><li>1、对同一个标签，如果用到了了多个相同的内嵌样式表，它的优先级：<strong>定义</strong>的样式表中，谁最近，就用谁。</li><li>2、对于同一个标签，如果引用了多个相同的外部样式表，它的优先级：html文件中，引用样式表的位置越近，就用谁。</li></ul><h3 id="important标记：优先级最高"><a href="#important标记：优先级最高" class="headerlink" title="!important标记：优先级最高"></a>!important标记：优先级最高</h3><p>important是英语里面的“重要的”的意思。我们可以通过如下语法：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">font-size</span><span class="token punctuation">:</span>60px <span class="token important">!important</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来给一个属性提高权重。这个属性的权重就是<strong>无穷大</strong>。</p><p>注意，一定要注意语法的正确性。</p><ol><li>!important提升的是一个属性，而不是一个选择器</li><li>!important无法提升继承的权重，该是0还是0</li><li>!important不影响就近原则</li></ol><h2 id="class和id的区别"><a href="#class和id的区别" class="headerlink" title="class和id的区别"></a>class和id的区别</h2><p>class用于css的，id用于js的。</p><ol><li>class页面上可以重复。id页面上唯一，不能重复。</li><li>一个标签可以有多个class，用空格隔开。但是id只能有id。</li></ol><h2 id="css两个性质"><a href="#css两个性质" class="headerlink" title="css两个性质"></a>css两个性质</h2><ul><li>继承性：好的事儿。继承从上到下，哪些能？哪些不能？</li><li>层叠性：冲突，多个选择器描述了同一个属性，听谁的？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS的继承性&quot;&gt;&lt;a href=&quot;#CSS的继承性&quot; class=&quot;headerlink&quot; title=&quot;CSS的继承性&quot;&gt;&lt;/a&gt;CSS的继承性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;继承性是从自己开始，直到最小的元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于文字样</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>03 CSS样式表和选择器</title>
    <link href="http://example.com/2022/02/25/03%20CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://example.com/2022/02/25/03%20CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-02-25T04:58:48.000Z</published>
    <updated>2022-02-25T05:31:21.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-和-HTML-结合的方式（样式表）"><a href="#CSS-和-HTML-结合的方式（样式表）" class="headerlink" title="CSS 和 HTML 结合的方式（样式表）"></a>CSS 和 HTML 结合的方式（样式表）</h2><p>CSS 和 HTML 的结合方式有 3 种：</p><ul><li><strong>行内样式</strong>：在某个特定的标签里采用 style<strong>属性</strong>。范围只针对此标签。</li><li><strong>内嵌样式表</strong>：在页面的 head 里采用<code>&lt;style&gt;</code><strong>标签</strong>。范围针对此页面。</li><li><strong>引入外部样式表 css 文件</strong>的方式。这种引入方式又分为两种： - 1、采用<code>&lt;link&gt;</code>标签。例如：<code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt;</code> - 2、采用 import，必须写在<code>&lt;style&gt;</code>标签中，并且必须是第一句。例如：<code>@import url(a.css) ;</code></li></ul><blockquote><p>两种引入样式方式的区别：外部样式表中不能写标签，但是可以写 import 语句。</p></blockquote><h2 id="CSS-的四种基本选择器"><a href="#CSS-的四种基本选择器" class="headerlink" title="CSS 的四种基本选择器"></a>CSS 的四种基本选择器</h2><p>CSS 的选择器分为两大类：基本选择题和扩展选择器。</p><p> <strong>基本选择器：</strong></p><ul><li>标签选择器：针对<strong>一类</strong>标签</li><li>ID 选择器：针对某<strong>一个</strong>特定的标签使用</li><li>类选择器：针对<strong>你想要的所有</strong>标签使用</li><li>通用选择器（通配符）：针对所有的标签都适用（不建议使用）</li></ul><h2 id="CSS-的几种高级选择器"><a href="#CSS-的几种高级选择器" class="headerlink" title="CSS 的几种高级选择器"></a>CSS 的几种高级选择器</h2><p><strong>高级选择器：</strong></p><ul><li>后代选择器：用空格隔开</li><li>交集选择器：选择器之间紧密相连</li><li>并集选择器（分组选择器）：用逗号隔开</li><li>伪类选择器</li></ul><h3 id="后代选择器-定义的时候用空格隔开"><a href="#后代选择器-定义的时候用空格隔开" class="headerlink" title="后代选择器: 定义的时候用空格隔开"></a>后代选择器: 定义的时候用空格隔开</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.div1 p</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="交集选择器：定义的时候紧密相连"><a href="#交集选择器：定义的时候紧密相连" class="headerlink" title="交集选择器：定义的时候紧密相连"></a>交集选择器：定义的时候紧密相连</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">h3.special</span> <span class="token punctuation">&#123;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="并集选择器：定义的时候用逗号隔开"><a href="#并集选择器：定义的时候用逗号隔开" class="headerlink" title="并集选择器：定义的时候用逗号隔开"></a>并集选择器：定义的时候用逗号隔开</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p,h1,#mytitle,.one</span> <span class="token punctuation">&#123;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一些-CSS3-选择器"><a href="#一些-CSS3-选择器" class="headerlink" title="一些 CSS3 选择器"></a>一些 CSS3 选择器</h2><h3 id="子代选择器，用符号-gt-表示"><a href="#子代选择器，用符号-gt-表示" class="headerlink" title="子代选择器，用符号&gt;表示"></a>子代选择器，用符号<code>&gt;</code>表示</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div > p</span> <span class="token punctuation">&#123;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">ul li:first-child</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">ul li:last-child</span> <span class="token punctuation">&#123;</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下一个兄弟选择器"><a href="#下一个兄弟选择器" class="headerlink" title="下一个兄弟选择器"></a>下一个兄弟选择器</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">h3 + p</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p><strong>伪类</strong>：同一个标签，根据其<strong>不同的种状态，有不同的样式</strong>。这就叫做“伪类”。伪类用冒号来表示。</p><h3 id="静态伪类和动态伪类"><a href="#静态伪类和动态伪类" class="headerlink" title="静态伪类和动态伪类"></a>静态伪类和动态伪类</h3><p>伪类选择器分为两种。</p><ol><li><strong>静态伪类</strong>：只能用于<strong>超链接</strong>的样式。如下：</li></ol><ul><li><code>:link</code> 超链接点击之前</li><li><code>:visited</code> 链接被访问过之后</li></ul><p>PS：以上两种样式，只能用于超链接。</p><ol start="2"><li><strong>动态伪类</strong>：针对<strong>所有标签</strong>都适用的样式。如下：</li></ol><ul><li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li><li><code>:active</code> “激活”： 鼠标点击标签，但是不松手时。</li><li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li></ul><h3 id="超链接的四种状态"><a href="#超链接的四种状态" class="headerlink" title="超链接的四种状态"></a>超链接的四种状态</h3><p>a标签有4种伪类（即对应四种状态），要求背诵。如下：</p><ul><li><code>:link</code> “链接”：超链接点击之前</li><li><code>:visited</code> “访问过的”：链接被访问过之后</li><li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li><li><code>:active</code> “激活”： 鼠标点击标签，但是不松手时。</li></ul><h3 id="动态伪类举例"><a href="#动态伪类举例" class="headerlink" title="动态伪类举例"></a>动态伪类举例</h3><p>我们在第一段中描述过，下面这三种动态伪类，针对所有标签都适用。</p><ul><li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li><li><code>:active</code> “激活”： 鼠标点击标签，但是不松手时。</li><li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS-和-HTML-结合的方式（样式表）&quot;&gt;&lt;a href=&quot;#CSS-和-HTML-结合的方式（样式表）&quot; class=&quot;headerlink&quot; title=&quot;CSS 和 HTML 结合的方式（样式表）&quot;&gt;&lt;/a&gt;CSS 和 HTML 结合的方式（样式表）&lt;/</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>02 背景属性</title>
    <link href="http://example.com/2022/02/25/02%20%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2022/02/25/02%20%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-25T04:57:16.000Z</published>
    <updated>2022-02-25T04:58:30.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="background-的常见背景属性"><a href="#background-的常见背景属性" class="headerlink" title="background 的常见背景属性"></a>background 的常见背景属性</h2><ul><li><code>background-color:#ff99ff;</code> 设置元素的背景颜色。</li><li><code>background-image:url(images/2.gif);</code> 将图像设置为背景。</li><li><code>background-repeat: no-repeat;</code> 设置背景图片是否重复及如何重复，默认平铺满。（重要）<ul><li><code>no-repeat</code>不要平铺；</li><li><code>repeat-x</code>横向平铺；</li><li><code>repeat-y</code>纵向平铺。</li></ul></li><li><code>background-position:center top;</code> 设置背景图片在当前容器中的位置。</li><li><code>background-attachment:scroll;</code> 设置背景图片是否跟着滚动条一起移动。 属性值可以是：<code>scroll</code>（与fixed属性相反，默认属性）、<code>fixed</code>（背景就会被固定住，不会被滚动条滚走）。</li><li>另外还有一个综合属性叫做<code>background</code>，它的作用是：将上面的多个属性写在一个声明中。</li></ul><p><strong>CSS3</strong> 中，新增了一些background属性：</p><ul><li>background-origin</li><li>background-clip 背景裁切</li><li>background-size 调整尺寸</li><li>多重背景</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;background-的常见背景属性&quot;&gt;&lt;a href=&quot;#background-的常见背景属性&quot; class=&quot;headerlink&quot; title=&quot;background 的常见背景属性&quot;&gt;&lt;/a&gt;background 的常见背景属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>01 字体属性和文本属性</title>
    <link href="http://example.com/2022/02/24/01%20%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2022/02/24/01%20%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-24T08:37:58.000Z</published>
    <updated>2022-02-25T05:20:40.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS的单位"><a href="#CSS的单位" class="headerlink" title="CSS的单位"></a>CSS的单位</h2><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>1 <code>in</code>&#x3D;2.54<code>cm</code>&#x3D;25.4<code>mm</code>&#x3D;72<code>pt</code>&#x3D;6<code>pc</code>。</p><p>各种单位的含义：</p><ul><li><code>in</code>：英寸Inches (1 英寸 &#x3D; 2.54 厘米)</li><li><code>cm</code>：厘米Centimeters</li><li><code>mm</code>：毫米Millimeters</li><li><code>pt</code>：点Points，或者叫英镑 (1点 &#x3D; 1&#x2F;72英寸)</li><li><code>pc</code>：皮卡Picas (1 皮卡 &#x3D; 12 点)</li></ul><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p><code>px</code>：像素 <code>em</code>：印刷单位相当于12个点 <code>%</code>：百分比，相对周围的文字的大小</p><h2 id="font-字体属性"><a href="#font-字体属性" class="headerlink" title="font 字体属性"></a>font 字体属性</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span> <span class="token comment">/*字体大小*/</span><span class="token property">line-height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>      <span class="token comment">/*行高*/</span><span class="token property">font-family</span><span class="token punctuation">:</span> 幼圆<span class="token punctuation">,</span>黑体<span class="token punctuation">;</span> <span class="token comment">/*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/</span><span class="token property">font-style</span><span class="token punctuation">:</span> italic <span class="token punctuation">;</span><span class="token comment">/*italic表示斜体，normal表示不倾斜*/</span><span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span><span class="token comment">/*粗体*/</span><span class="token property">font-variant</span><span class="token punctuation">:</span> small-caps<span class="token punctuation">;</span>  <span class="token comment">/*小写变大写*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>CSS样式中，常见的文本属性有以下几种：</p><ul><li><code>letter-spacing: 0.5cm ;</code> 单个字母之间的间距</li><li><code>word-spacing: 1cm;</code> 单词之间的间距</li><li><code>text-decoration: none;</code> 字体修饰：none 去掉下划线、<strong>underline 下划线</strong>、line-through 中划线、overline 上划线</li><li><code>text-transform: lowercase;</code> 单词字体大小写。uppercase大写、lowercase小写</li><li><code>color:red;</code> 字体颜色</li><li><code>text-align: center;</code> 在当前容器中的对齐方式。属性值可以是：left、right、center（<strong>在当前容器的中间</strong>）、justify</li><li><code>text-transform: lowercase;</code> 单词的字体大小写。属性值可以是：<code>uppercase</code>（单词大写）、<code>lowercase</code>（单词小写）、<code>capitalize</code>（每个单词的首字母大写）</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-18.png" alt="img"></p><h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">ul li</span><span class="token punctuation">&#123;</span><span class="token property">list-style-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>images/2.gif<span class="token punctuation">)</span></span> <span class="token punctuation">;</span>  <span class="token comment">/*列表项前设置为图片*/</span><span class="token property">margin-left</span><span class="token punctuation">:</span>80px<span class="token punctuation">;</span>  <span class="token comment">/*公有属性*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-26.png" alt="img"></p><h2 id="overflow属性：超出范围的内容要怎么处理"><a href="#overflow属性：超出范围的内容要怎么处理" class="headerlink" title="overflow属性：超出范围的内容要怎么处理"></a>overflow属性：超出范围的内容要怎么处理</h2><p><code>overflow</code>属性的属性值可以是：</p><ul><li><code>visible</code>：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。</li><li><code>hidden</code>：不显示超过对象尺寸的内容。</li><li><code>auto</code>：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。</li><li><code>scroll</code>：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 <code>auto</code> 属性相同。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS的单位&quot;&gt;&lt;a href=&quot;#CSS的单位&quot; class=&quot;headerlink&quot; title=&quot;CSS的单位&quot;&gt;&lt;/a&gt;CSS的单位&lt;/h2&gt;&lt;h3 id=&quot;绝对单位&quot;&gt;&lt;a href=&quot;#绝对单位&quot; class=&quot;headerlink&quot; title=&quot;绝</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/2022/02/24/HTML/"/>
    <id>http://example.com/2022/02/24/HTML/</id>
    <published>2022-02-24T08:37:50.000Z</published>
    <updated>2022-02-25T04:32:35.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特殊字符（转义字符）"><a href="#特殊字符（转义字符）" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/3533a024e850b5b8.png"></p><h2 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5"></a>什么是 HTML5</h2><p>HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它<strong>制定了Web应用开发的一系列标准</strong>，成为第一个将Web做为应用开发平台的HTML语言。</p><p>HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。</p><p><strong><code>HTML5</code>的广义概念</strong>：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。</p><p><code>HTML5</code>不等于 <code>HTML next version</code>。<code>HTML5</code> 包含： <code>HTML</code>的升级版、<code>CSS</code>的升级版、<code>JavaScript API</code>的升级版。</p><p><strong>总结</strong>：<code>HTML5</code>是新一代开发 <strong>Web 富客户端</strong>应用程序整体<strong>解决方案</strong>。包括：HTML5，CSS3，Javascript API在内的一套<strong>技术组合</strong>。</p><p><strong>富客户端</strong>：具有很强的<strong>交互性</strong>和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。</p><h2 id="HTML5-新增的内容"><a href="#HTML5-新增的内容" class="headerlink" title="HTML5 新增的内容"></a>HTML5 新增的内容</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1540.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1545.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1541.png" alt="img"></p><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><h3 id="语义化的作用"><a href="#语义化的作用" class="headerlink" title="语义化的作用"></a>语义化的作用</h3><p>语义标签对于我们并不陌生，如<code>&lt;p&gt;</code>表示一个段落、<code>&lt;ul&gt;</code>表示一个无序列表。<strong>标签语义化的作用：</strong></p><ul><li>能够便于开发者阅读和写出更优雅的代码。</li><li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。</li><li>更好地搜索引擎优化。</li></ul><h3 id="H5在语义上的改进"><a href="#H5在语义上的改进" class="headerlink" title="H5在语义上的改进"></a>H5在语义上的改进</h3><p>HTML：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1546.png" alt="img"></p><p>HTML 5：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1550.png" alt="img"></p><p><strong>传统网页布局：</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 头部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 主体部分 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 文章 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 侧边栏 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aside<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 底部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>H5 的经典网页布局：</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 头部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 主体部分 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 文章 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 侧边栏 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aside</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 底部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;section&gt;</code> 表示区块</li><li><code>&lt;article&gt;</code> 表示文章。如文章、评论、帖子、博客</li><li><code>&lt;header&gt;</code> 表示页眉</li><li><code>&lt;footer&gt;</code> 表示页脚</li><li><code>&lt;nav&gt;</code> 表示导航</li><li><code>&lt;aside&gt;</code> 表示侧边栏。如文章的侧栏</li><li><code>&lt;figure&gt;</code> 表示媒介内容分组。</li><li><code>&lt;mark&gt;</code> 表示标记 (用得少)</li><li><code>&lt;progress&gt;</code> 表示进度 (用得少)</li><li><code>&lt;time&gt;</code> 表示日期</li></ul><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li>document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。</li><li>document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。</li></ul><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><ul><li>Node.classList.add(“class”) 添加class</li><li>Node.classList.remove(“class”) 移除class</li><li>Node.classList.toggle(“class”) 切换class，有则移除，无则添加</li><li>Node.classList.contains(“class”) 检测是否存在class</li></ul><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>js 里可以通过 <code>box1.index=100;</code> <code>box1.title</code> 来自定义属性和获取属性。</p><p>H5可以直接在标签里添加自定义属性，<strong>但必须以 <code>data-</code> 开头</strong>。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 给标签添加自定义属性 必须以data-开头 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>盒子<span class="token punctuation">"</span></span> <span class="token attr-name">data-my-name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>smyhvae<span class="token punctuation">"</span></span> <span class="token attr-name">data-content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>我是一个div<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//自定义的属性 需要通过 dateset[]方式来获取</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"content"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印结果：我是一个div</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"myName"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//打印结果：smyhvae</span>    <span class="token comment">//设置自定义属性的值</span>    <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    num<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    box<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"content"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"aaaa"</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。</p><p>在HTML5中可以通过 <code>window.history</code> 操作访问历史状态，让一个页面可以有多个历史状态</p><p><code>window.history</code>对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。</p><ul><li>window.history.forward(); &#x2F;&#x2F; 前进</li><li>window.history.back(); &#x2F;&#x2F; 后退</li><li>window.history.go(); &#x2F;&#x2F; 刷新</li><li>window.history.go(n); &#x2F;&#x2F;n&#x3D;1 表示前进；n&#x3D;-1 后退；n&#x3D;0s 刷新。如果移动的位置超出了访问历史的边界，会静默失败，但不会报错。</li><li>通过JS可以加入一个访问状态</li><li>history.pushState; &#x2F;&#x2F;放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态)</li></ul><h2 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h2><p>在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即<strong>基于位置服务 LBS</strong> (Location Base Service)。</p><h3 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h3><ul><li>navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息</li><li>navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息</li></ul><p>1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标）</p><ul><li>position.coords.latitude纬度</li><li>position.coords.longitude经度</li></ul><p>2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。</p><p>3、可选参数 options 对象可以调整位置信息数据收集方式</p><h2 id="Web-存储"><a href="#Web-存储" class="headerlink" title="Web 存储"></a>Web 存储</h2><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。</p><h3 id="H5-中有两种存储的方式"><a href="#H5-中有两种存储的方式" class="headerlink" title="H5 中有两种存储的方式"></a>H5 中有两种存储的方式</h3><p>1、**<code>window.sessionStorage</code> 会话存储：**</p><ul><li>保存在内存中。</li><li><strong>生命周期</strong>为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。</li><li>在同一个窗口下数据可以共享。</li></ul><p>2、**<code>window.localStorage</code> 本地存储**：</p><ul><li>有可能保存在浏览器内存里，有可能在硬盘里。</li><li>永久生效，除非手动删除（比如清理垃圾的时候）。</li><li>可以多窗口共享。</li></ul><h3 id="Web-存储的特性"><a href="#Web-存储的特性" class="headerlink" title="Web 存储的特性"></a>Web 存储的特性</h3><p>（1）设置、读取方便。</p><p>（2）容量较大，sessionStorage 约5M、localStorage 约20M。</p><p>（3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。</p><h3 id="常见-API"><a href="#常见-API" class="headerlink" title="常见 API"></a>常见 API</h3><p>设置存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS：可以新增一个 item，也可以更新一个 item。</p><p>读取存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据键，删除存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">removeItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清空所有存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据索引值来获取存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">key</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="html-元素的分类"><a href="#html-元素的分类" class="headerlink" title="html 元素的分类"></a>html 元素的分类</h2><h3 id="按照样式分类："><a href="#按照样式分类：" class="headerlink" title="按照样式分类："></a>按照样式分类：</h3><ul><li>块级元素</li><li>行内元素</li><li>inline-block：比如<code>form</code>表单元素。对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。</li></ul><h2 id="html常见面试题"><a href="#html常见面试题" class="headerlink" title="html常见面试题"></a>html常见面试题</h2><h3 id="HTML、XHTML、HTML5的区别"><a href="#HTML、XHTML、HTML5的区别" class="headerlink" title="HTML、XHTML、HTML5的区别"></a>HTML、XHTML、HTML5的区别</h3><ul><li>HTML 属于 SGML</li><li>XHTML 属于 XML，是 HTML 进行 XML 严格化的结果</li><li>HTML5 不属于SGML，也不属于 XML（HTML5有自己独立的一套规范），比 XHTML 宽松。</li></ul><h3 id="HTML5-有什么新的变化"><a href="#HTML5-有什么新的变化" class="headerlink" title="HTML5 有什么新的变化"></a>HTML5 有什么新的变化</h3><ul><li>新的语义化元素</li><li>表单增强</li><li>新的API：离线、音视频、图形、实时通信、本地存储、设备能力等。</li></ul><h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul><li>开发者容易理解，便于维护。</li><li>机器（搜索引擎、读屏软件等）容易理解结构</li><li>有助于 SEO</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;特殊字符（转义字符）&quot;&gt;&lt;a href=&quot;#特殊字符（转义字符）&quot; class=&quot;headerlink&quot; title=&quot;特殊字符（转义字符）&quot;&gt;&lt;/a&gt;特殊字符（转义字符）&lt;/h2&gt;&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGO</summary>
      
    
    
    
    <category term="HTML" scheme="http://example.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流</title>
    <link href="http://example.com/2022/02/23/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2022/02/23/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2022-02-23T12:48:57.000Z</published>
    <updated>2022-02-23T13:07:50.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'增加一个'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> timer  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments    timer<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">scrollTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'现在我触发了'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> t1 <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">//初始时间</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//当前时间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t2 <span class="token operator">-</span> t1 <span class="token operator">></span> time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>      t1 <span class="token operator">=</span> t2    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span><span class="token function">throttle</span><span class="token punctuation">(</span>scrollTest<span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;p&gt;n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-js</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="杂" scheme="http://example.com/categories/JavaScript/%E6%9D%82/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Async/Await</title>
    <link href="http://example.com/2022/02/23/Async-Await/"/>
    <id>http://example.com/2022/02/23/Async-Await/</id>
    <published>2022-02-23T11:44:15.000Z</published>
    <updated>2022-02-23T11:49:33.020Z</updated>
    
    <content type="html"><![CDATA[<p>ES7 提出的<code>async</code> 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。<br><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="async-函数返回一个-Promise-对象"><a href="#async-函数返回一个-Promise-对象" class="headerlink" title="async 函数返回一个 Promise 对象"></a><strong>async 函数返回一个 Promise 对象</strong></h3><p><code>async</code> 函数内部 return 返回的值。会成为 <code>then</code> 方法回调函数的参数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>async</code> 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 <code>reject</code> 状态。抛出的错误而会被 <code>catch</code> 方法回调函数接收到。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span> <span class="token parameter">e</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="async-函数返回的-Promise-对象，必须等到内部所有的-await-命令的-Promise-对象执行完，才会发生状态改变"><a href="#async-函数返回的-Promise-对象，必须等到内部所有的-await-命令的-Promise-对象执行完，才会发生状态改变" class="headerlink" title="async 函数返回的 Promise 对象，必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变"></a><strong>async 函数返回的 Promise 对象，必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变</strong></h3><p>也就是说，只有当 <code>async</code> 函数内部的异步操作都执行完，才会执行 <code>then</code> 方法的回调。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">delay</span> <span class="token operator">=</span> <span class="token parameter">timeout</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">'done'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待6s后才输出 'done'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>正常情况下，await 命令后面跟着的是 Promise ，如果不是的话，也会被转换成一个 立即 resolve 的 Promise</strong><br>如下面这个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果返回的是 reject 的状态，则会被 <code>catch</code> 方法捕获。</p><h2 id="Async-函数的错误处理"><a href="#Async-函数的错误处理" class="headerlink" title="Async 函数的错误处理"></a>Async 函数的错误处理</h2><p><code>async</code> 函数的语法不难，难在错误处理上。<br>先来看下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这段 await 并没有执行</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面所示，当 <code>async</code> 函数中只要一个 <code>await</code> 出现 reject 状态，则后面的 <code>await</code> 都不会被执行。<br><strong>解决办法</strong>：可以添加 <code>try/catch</code>。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 正确的写法</span><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">correct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">correct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多个 <code>await</code> 则可以将其都放在 <code>try/catch</code> 中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES7 提出的&lt;code&gt;async&lt;/code&gt; 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。&lt;br&gt;&lt;code&gt;async&lt;/code&gt; 函数是 &lt;code&gt;Generator&lt;/code&gt; 函数的语法糖</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://example.com/2022/02/23/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2022/02/23/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-02-23T09:04:10.000Z</published>
    <updated>2022-02-23T11:09:17.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。</li><li>深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。</li></ul><p>拷贝引用的时候，是属于<strong>传址</strong>，而非<strong>传值</strong>。关于传值和传址的区别，是很基础的内容，详见《JavaScript 基础&#x2F;对象简介.md》这篇文章。</p><p>深拷贝会把对象里<strong>所有的数据</strong>重新复制到新的内存空间，是最彻底的拷贝。</p><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><h3 id="用-for-in-实现浅拷贝（比较繁琐）"><a href="#用-for-in-实现浅拷贝（比较繁琐）" class="headerlink" title="用 for in 实现浅拷贝（比较繁琐）"></a>用 for in 实现浅拷贝（比较繁琐）</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'很厉害'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//  用 for in 将 obj1 的值拷贝给 obj2</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    obj2<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'永不止步'</span><span class="token punctuation">;</span> <span class="token comment">// 当修改 obj1 的第二层数据时，obj2的值也会被改变。所以  for in 是浅拷贝</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，<code>obj2.info</code> 属性，跟 <code>obj1.info</code>属性，<strong>它俩指向的是同一个堆内存地址</strong>。所以，当我修改 <code>obj1.info</code> 里的值之后，<code>obj2.info</code>的值也会被修改。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">obj2</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string-property property">"info"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"很厉害"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token literal-property property">obj2</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string-property property">"info"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"永不止步"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="用-Object-assgin-实现浅拷贝（推荐的方式）"><a href="#用-Object-assgin-实现浅拷贝（推荐的方式）" class="headerlink" title="用 Object.assgin() 实现浅拷贝（推荐的方式）"></a>用 Object.assgin() 实现浅拷贝（推荐的方式）</h3><p>上面的 for in 方法做浅拷贝过于繁琐。ES6 给我们提供了新的语法糖，通过 <code>Object.assgin()</code> 可以实现<strong>浅拷贝</strong>。</p><p><code>Object.assgin()</code> 在日常开发中，使用得相当频繁，非掌握不可。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 语法1</span>obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assgin</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 语法2</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>目标对象<span class="token punctuation">,</span> 源对象<span class="token number">1</span><span class="token punctuation">,</span> 源对象<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释</strong>：将<code>obj1</code> 拷贝给 <code>obj2</code>。执行完毕后，obj2 的值会被更新。</p><p><strong>作用</strong>：将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。</p><p>从语法2中可以看出，Object.assign() 可以将多个“源对象”拷贝到“目标对象”中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 浅拷贝：把 obj1 拷贝给 obj2。如果 obj1 只有一层数据，那么，obj1 和 obj2 则互不影响</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'永不止步'</span><span class="token punctuation">;</span> <span class="token comment">// 由于 Object.assign() 只是浅拷贝，所以当修改 obj1 的第二层数据时，obj2 对应的值也会被改变。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> myObj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 【写法1】浅拷贝：把 myObj 拷贝给 obj1</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 【写法2】浅拷贝：把 myObj 拷贝给 obj2</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址</span><span class="token keyword">const</span> obj31 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj32 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj31<span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">26</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">city</span><span class="token operator">:</span> <span class="token string">'shenzhen'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj3<span class="token punctuation">,</span> obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 obj1、obj2的内容赋值给 obj3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;name: "qianguyihao", age: 28, city: "shenzhen"&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'许嵩'</span><span class="token punctuation">,</span>    <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 浅拷贝：把 obj1 赋值给 obj2。这一行，是关键代码。这行代码的返回值也是 obj2</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>    <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span>    <span class="token string-property property">"sex"</span><span class="token operator">:</span><span class="token string">"男"</span><span class="token punctuation">,</span>    <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span>    <span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"hello world"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p>深拷贝其实就是将浅拷贝进行递归。</p><h3 id="用-for-in-递归实现深拷贝"><a href="#用-for-in-递归实现深拷贝" class="headerlink" title="用 for in 递归实现深拷贝"></a>用 for in 递归实现深拷贝</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'github'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 方法：深拷贝</span><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">newObj<span class="token punctuation">,</span> oldObj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> oldObj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取属性值 oldObj[key]</span>        <span class="token keyword">let</span> item <span class="token operator">=</span> oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 判断这个值是否是数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断这个值是否是对象</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 简单数据类型，直接赋值</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。&lt;/li&gt;
&lt;li&gt;深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="杂" scheme="http://example.com/categories/JavaScript/%E6%9D%82/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://example.com/2022/02/23/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2022/02/23/%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-02-23T03:59:42.000Z</published>
    <updated>2022-02-23T11:55:59.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1400.png" alt="img"></p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180228_1505.jpg" alt="img"></p><ul><li>请求行：包括请求方法、请求的url、http协议及版本。</li><li>请求头：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li>请求体：数据部分。</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180228_1510.jpg" alt="img"></p><ul><li>状态行：http协议及版本、状态码及状态描述。</li><li>响应头</li><li>空行</li><li>响应体</li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>put：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获得报文首部</li></ul><p>HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p><p>get 和 post 比较常见。</p><p>put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</p><p>head 可能偶尔用的到。</p><h2 id="get-和-post的区别"><a href="#get-和-post的区别" class="headerlink" title="get 和 post的区别"></a>get 和 post的区别</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1415.png" alt="img"></p><p><strong>get是相对不隐私的，而post是相对隐私的</strong>。</p><ol><li>浏览器在回退时，get<strong>不会重新请求</strong>，但是post会重新请求。【重要】</li><li>get请求会被浏览器<strong>主动缓存</strong>，而post不会。【重要】</li><li>get请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。</li><li>get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。</li><li>get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。</li></ol><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><h3 id="http状态码分类"><a href="#http状态码分类" class="headerlink" title="http状态码分类"></a>http状态码分类</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1430.png" alt="img"></p><h3 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1431.png" alt="img"></p><h3 id="部分解释"><a href="#部分解释" class="headerlink" title="部分解释"></a>部分解释</h3><ul><li>206的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。</li><li>301：重定向（永久）。</li><li>302：重定向（临时）。</li><li>304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1440.png" alt="img"></p><p>400和401用的不多。403指的是请求被拒绝。404指的是资源不存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP报文的组成部分&quot;&gt;&lt;a href=&quot;#HTTP报文的组成部分&quot; class=&quot;headerlink&quot; title=&quot;HTTP报文的组成部分&quot;&gt;&lt;/a&gt;HTTP报文的组成部分&lt;/h2&gt;&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://example.com/2022/02/23/Ajax/"/>
    <id>http://example.com/2022/02/23/Ajax/</id>
    <published>2022-02-23T03:59:20.000Z</published>
    <updated>2022-02-23T11:54:54.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax入门和发送http请求"><a href="#Ajax入门和发送http请求" class="headerlink" title="Ajax入门和发送http请求"></a>Ajax入门和发送http请求</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>Ajax：Asynchronous Javascript And XML（异步 JavaScript 和 XML）。它并不是凭空出现的新技术，而是对于现有技术的结合。Ajax 的核心是 js 对象：<strong>XMLHttpRequest</strong>。</p><h4 id="Ajax-原理（发送-Ajax-请求的五个步骤）"><a href="#Ajax-原理（发送-Ajax-请求的五个步骤）" class="headerlink" title="Ajax 原理（发送 Ajax 请求的五个步骤）"></a>Ajax 原理（发送 Ajax 请求的五个步骤）</h4><p>一个完整的 HTTP 请求需要的是：</p><ul><li>请求的网址、请求方法 get&#x2F;post。</li><li>提交请求的内容数据、请求主体等。</li><li>接收响应回来的内容。</li></ul><p>发送 Ajax 请求的五个步骤：</p><ol><li>创建异步对象，即 XMLHttpRequest 对象。</li><li>使用 open 方法设置请求参数。<code>open(method, url, async)</code>。参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。</li><li>发送请求：<code>send()</code>。</li><li>注册事件：注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</li><li>服务端响应，获取返回的数据。</li></ol><h3 id="XMLHttpRequest-对象详解"><a href="#XMLHttpRequest-对象详解" class="headerlink" title="XMLHttpRequest 对象详解"></a>XMLHttpRequest 对象详解</h3><p>发送请求的方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> async<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释：</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul><p>另外还有个方法：（仅用于 POST 请求）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">send</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="POST-请求时注意"><a href="#POST-请求时注意" class="headerlink" title="POST 请求时注意"></a>POST 请求时注意</h3><p>如果想让 像 form 表单提交数据那样使用 POST 请求，就需要使用 XMLHttpRequest 对象的 setRequestHeader()方法 来添加 HTTP 头。然后在 send() 方法中添加想要发送的数据：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'ajax_test.php'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'name=smyhvae&amp;age=27'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。</p><p>readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化）</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul><p>status：</p><ul><li>200: “OK”。</li><li>404: 未找到页面。</li></ul><p>在 onreadystatechange 事件中，<strong>当 readyState 等于 4，且状态码为 200 时，表示响应已就绪</strong>。</p><h4 id="服务器响应的内容"><a href="#服务器响应的内容" class="headerlink" title="服务器响应的内容"></a>服务器响应的内容</h4><ul><li>responseText：获得字符串形式的响应数据。</li><li>responseXML：获得 XML 形式的响应数据。</li></ul><p>如果响应的是普通字符串，就使用 responseText；如果响应的是 XML，使用 responseXML。</p><h3 id="jQuery-中的-Ajax"><a href="#jQuery-中的-Ajax" class="headerlink" title="jQuery 中的 Ajax"></a>jQuery 中的 Ajax</h3><p>格式举例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://xxx.com/getUserInfo.php'</span><span class="token punctuation">,</span> <span class="token comment">// 接口的请求地址</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token string">'name=fox&amp;age=18'</span><span class="token punctuation">,</span> <span class="token comment">// 请求参数</span>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token comment">//请求的方式</span>    <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接口请求成功时调用</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'接口请求成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">beforeSend</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 在发送请求之前调用,可以做一些验证之类的处理</span>    <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接口请求失败时调用</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'接口请求失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ajax传输JSON"><a href="#Ajax传输JSON" class="headerlink" title="Ajax传输JSON"></a>Ajax传输JSON</h2><p>JSON(JavaScript Object Notation)：是 ECMAScript 的子集。作用是进行数据的交换。语法更为简洁，网络传输、机器解析都更为迅速。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 对象</span><span class="token punctuation">&#123;</span>  <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"fox"</span><span class="token punctuation">,</span>  <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"18"</span><span class="token punctuation">,</span>  <span class="token string-property property">"sex"</span><span class="token operator">:</span><span class="token string">"true"</span><span class="token punctuation">,</span>  <span class="token string-property property">"car"</span><span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">&#125;</span><span class="token comment">// 数组</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>      <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小小胡"</span><span class="token punctuation">,</span>      <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"1"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>      <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小二胡"</span><span class="token punctuation">,</span>      <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON-字符串-lt-–-gt-JS-对象"><a href="#JSON-字符串-lt-–-gt-JS-对象" class="headerlink" title="JSON 字符串 &lt;–&gt; JS 对象"></a>JSON 字符串 &lt;–&gt; JS 对象</h3><p>JSON.parse()：将 JSON 字符串转化为 js 对象。例如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 将 JSON 字符串格式化为 js 对象</span><span class="token keyword">var</span> jsObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ajax<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>JSON.stringify()：将 JS 对象转化为 JSON 字符串。例如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> Obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'fox'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token literal-property property">skill</span><span class="token operator">:</span> <span class="token string">'撩妹'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 js 对象格式化为 JSON 字符串</span><span class="token keyword">var</span> jsonStr <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>Obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ajax入门和发送http请求&quot;&gt;&lt;a href=&quot;#Ajax入门和发送http请求&quot; class=&quot;headerlink&quot; title=&quot;Ajax入门和发送http请求&quot;&gt;&lt;/a&gt;Ajax入门和发送http请求&lt;/h2&gt;&lt;h3 id=&quot;Ajax&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Ajax" scheme="http://example.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM与Diff算法</title>
    <link href="http://example.com/2022/02/22/%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/22/%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-22T14:07:16.000Z</published>
    <updated>2022-02-25T12:36:27.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p><code>虚拟DOM</code>是一个<code>对象</code>，一个什么样的对象呢？<strong>一个用来表示真实DOM的对象</strong></p><p>以下<code>真实DOM</code>：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"list"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>哈哈<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>呵呵<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>嘿嘿<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的<code>虚拟DOM</code>为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> oldVDOM <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 旧虚拟DOM</span>        <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token comment">// 标签名</span>        <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 标签属性</span>            <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'list'</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// 标签子节点</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'哈哈'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'呵呵'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'嘿嘿'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0089a781a80244308472447b86cad21e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-07 下午10.24.17.png"></p><p>由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个<code>虚拟DOM</code>的步骤，所以<strong>虚拟DOM比真实DOM快</strong>这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？<strong>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</strong>，<code>虚拟DOM</code>和<code>虚拟DOM算法</code>是两种概念。<code>虚拟DOM算法 = 虚拟DOM + Diff算法</code></p><h2 id="什么是Diff算法"><a href="#什么是Diff算法" class="headerlink" title="什么是Diff算法"></a>什么是Diff算法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c57a7b4e91a4a359474fb4c281f6d8e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-07 下午10.59.31.png"></p><p>总结：<strong>Diff算法是一种对比算法</strong>。对比两者是<code>旧虚拟DOM和新虚拟DOM</code>，对比出是哪个<code>虚拟节点</code>更改了，找出这个<code>虚拟节点</code>，并只更新这个虚拟节点所对应的<code>真实节点</code>，而不用更新其他数据没发生改变的节点，实现<code>精准</code>地更新真实DOM，进而<code>提高效率</code>。</p><ul><li><code>使用虚拟DOM算法的损耗计算</code>： 总损耗 &#x3D; 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</li><li><code>直接操作真实DOM的损耗计算</code>： 总损耗 &#x3D; 真实DOM完全增删改+（可能较多的节点）排版与重绘</li></ul><h2 id="Diff算法的原理"><a href="#Diff算法的原理" class="headerlink" title="Diff算法的原理"></a>Diff算法的原理</h2><h3 id="Diff同层对比"><a href="#Diff同层对比" class="headerlink" title="Diff同层对比"></a>Diff同层对比</h3><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca3d338e5a445ab80e40042c50ac79a~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.32.47.png"></p><h3 id="Diff对比流程"><a href="#Diff对比流程" class="headerlink" title="Diff对比流程"></a>Diff对比流程</h3><p><code>newVnode和oldVnode</code>：同层的新旧虚拟节点</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.49.38.png"></p><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p><ul><li>是：继续执行<code>patchVnode方法</code>进行深层比对</li><li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li></ul><p>来看看<code>patch</code>的核心原理代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 比较是否为一个类型的节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 是：继续进行深层比较</span>    <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 否</span>    <span class="token keyword">const</span> oldEl <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el <span class="token comment">// 旧虚拟节点的真实DOM节点</span>    <span class="token keyword">const</span> parentEle <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>oldEl<span class="token punctuation">)</span> <span class="token comment">// 获取父节点</span>    <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span> <span class="token comment">// 创建新虚拟节点对应的真实DOM节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentEle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oEl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 将新元素添加进父元素</span>      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>  <span class="token comment">// 移除以前的旧元素节点</span>      <span class="token comment">// 设置null，释放内存</span>      oldVnode <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> newVnode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sameVnode方法"><a href="#sameVnode方法" class="headerlink" title="sameVnode方法"></a>sameVnode方法</h3><p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code>，那问题来了，怎么才算是同一类型节点呢？这个<code>类型</code>的标准是什么呢？</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    oldVnode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token comment">// key值是否一样</span>    oldVnode<span class="token punctuation">.</span>tagName <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>tagName <span class="token operator">&amp;&amp;</span> <span class="token comment">// 标签名是否一样</span>    oldVnode<span class="token punctuation">.</span>isComment <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都为注释节点</span>    <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都定义了data</span>    <span class="token function">sameInputType</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span> <span class="token comment">// 当标签为input时，type必须是否相同</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="patchVnode方法"><a href="#patchVnode方法" class="headerlink" title="patchVnode方法"></a>patchVnode方法</h3><p>这个函数做了以下事情：</p><ul><li>找到对应的<code>真实DOM</code>，称为<code>el</code></li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patchVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> el <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>el <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el <span class="token comment">// 获取真实DOM对象</span>  <span class="token comment">// 获取新旧虚拟节点的子节点数组</span>  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> newCh <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>children  <span class="token comment">// 如果新旧虚拟节点是同一个对象，则终止</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> newVnode<span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token comment">// 如果新旧虚拟节点是文本节点，且文本不一样</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span>    api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 否则</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">&amp;&amp;</span> newCh <span class="token operator">&amp;&amp;</span> oldCh <span class="token operator">!==</span> newCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 新旧虚拟节点都有子节点，且子节点不一样</span>      <span class="token comment">// 对比子节点，并更新</span>      <span class="token function">updateChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 新虚拟节点有子节点，旧虚拟节点没有</span>      <span class="token comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span>      <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 旧虚拟节点有子节点，新虚拟节点没有</span>      <span class="token comment">//直接删除真实DOM里对应的子节点</span>      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h3><p>新旧两个子节点集合以及其首尾指针为：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb33b1b28e7461f9aedb857736a142c~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午2.55.26.png"></p><p>然后会进行互相进行比较，总共有五种比较情况：</p><ul><li>1、<code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li><li>2、<code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li><li>3、<code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li><li>4、<code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li><li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727b5dd8a3424d22afd9dc5cf0dae05e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午2.57.22.png"></p><h2 id="用index做key"><a href="#用index做key" class="headerlink" title="用index做key"></a>用index做key</h2><p>在进行子节点的 <code>diff算法</code> 过程中，会进行 旧首节点和新首节点的<code>sameNode</code>对比，这一步命中了逻辑，因为现在<code>新旧两次首部节点</code> 的 <code>key</code> 都是 <code>0</code>了，同理，key为1和2的也是命中了逻辑，导致<code>相同key的节点</code>会去进行<code>patchVnode</code>更新文本，而原本就有的<code>c节点</code>，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行<code>patchVnode</code>更新文本，最后一个进行了<code>新增</code>，那就解释了为什么所有li标签都更新了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc93fb2bc544a83b8cc7b7cbcaf1857~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午5.45.17.png"></p><p>为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，<code>a，b，c节点</code>的<code>key</code>就会是永远不变的，更新前后key都是一样的，并且又由于<code>a，b，c节点</code>的内容本来就没变，所以就算是进行了<code>patchVnode</code>，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833e0a795a3e4893a0c03bb78a63bffc~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午6.04.34.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是虚拟DOM&quot;&gt;&lt;a href=&quot;#什么是虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟DOM&quot;&gt;&lt;/a&gt;什么是虚拟DOM&lt;/h2&gt;&lt;p&gt;&lt;code&gt;虚拟DOM&lt;/code&gt;是一个&lt;code&gt;对象&lt;/code&gt;，一个什么样的对象呢</summary>
      
    
    
    
    <category term="Vue.js" scheme="http://example.com/categories/Vue-js/"/>
    
    <category term="Vue进阶" scheme="http://example.com/categories/Vue-js/Vue%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Vue.js" scheme="http://example.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>微任务、宏任务与Event-Loop</title>
    <link href="http://example.com/2022/02/22/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-Loop/"/>
    <id>http://example.com/2022/02/22/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-Loop/</id>
    <published>2022-02-22T11:54:38.000Z</published>
    <updated>2022-02-22T13:13:59.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是宏任务与微任务？"><a href="#什么是宏任务与微任务？" class="headerlink" title="什么是宏任务与微任务？"></a>什么是宏任务与微任务？</h2><p>我们都知道 Js 是单线程都，但是一些高耗时操作就带来了进程阻塞问题。为了解决这个问题，Js 有两种任务的执行模式：<strong>同步模式（Synchronous）和异步模式（Asynchronous）</strong>。</p><p>在异步模式下，创建<strong>异步任务主要分为宏任务与微任务两种</strong>。ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。</p><h2 id="如何理解-script（整体代码块）是个宏任务呢"><a href="#如何理解-script（整体代码块）是个宏任务呢" class="headerlink" title="如何理解 script（整体代码块）是个宏任务呢"></a><strong>如何理解 script（整体代码块）是个宏任务呢</strong></h2><p>实际上如果同时存在两个 script 代码块，会首先在执行第一个 script 代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去清空微任务队列，再去开启第二个 script 代码块的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><h2 id="什么是-EventLoop-？"><a href="#什么是-EventLoop-？" class="headerlink" title="什么是 EventLoop ？"></a>什么是 EventLoop ？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baaf009636748c491898aafeceddb32~tplv-k3u1fbpfcp-watermark.awebp" alt="EventLoop.png"></p><p>因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 Js 解析完成后，在异步任务中，会先执行完所有的微任务，这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是宏任务与微任务？&quot;&gt;&lt;a href=&quot;#什么是宏任务与微任务？&quot; class=&quot;headerlink&quot; title=&quot;什么是宏任务与微任务？&quot;&gt;&lt;/a&gt;什么是宏任务与微任务？&lt;/h2&gt;&lt;p&gt;我们都知道 Js 是单线程都，但是一些高耗时操作就带来了进程阻塞问题</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://example.com/2022/02/22/Promise/"/>
    <id>http://example.com/2022/02/22/Promise/</id>
    <published>2022-02-22T10:05:58.000Z</published>
    <updated>2022-02-22T11:52:21.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Promise？我们用Promise来解决什么问题？"><a href="#什么是Promise？我们用Promise来解决什么问题？" class="headerlink" title="什么是Promise？我们用Promise来解决什么问题？"></a>什么是Promise？我们用Promise来解决什么问题？</h2><blockquote><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</p></blockquote><p>promise是用来解决两个问题的：</p><ul><li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li><li>promise可以支持多个并发的请求，获取并发请求中的数据</li><li>这个promise可以解决异步的问题，本身不能说promise是异步的</li></ul><h2 id="es6-promise用法大全"><a href="#es6-promise用法大全" class="headerlink" title="es6 promise用法大全"></a>es6 promise用法大全</h2><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p><p>那就new一个</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//做一些异步操作</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'我是成功！！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：</p><ul><li>resolve ：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul><h3 id="then-链式操作的用法"><a href="#then-链式操作的用法" class="headerlink" title="then 链式操作的用法"></a>then 链式操作的用法</h3><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法 :"></a>reject的用法 :</h3><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//做一些异步操作</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成1-10的随机数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'数字太大了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-watermark.awebp" alt="img">或者<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h3><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>somedata<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处的somedata未定义</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/1637880bdb32bee3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try&#x2F;catch语句有相同的功能</p><h3 id="all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象"><a href="#all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象" class="headerlink" title="all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象"></a>all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象</h3><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> Promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise1<span class="token punctuation">,</span> Promise2<span class="token punctuation">,</span> Promise3<span class="token punctuation">]</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 三个都成功则成功  </span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 只要有失败，则失败 </span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据</p><h3 id="race的用法：谁跑的快，以谁为准执行回调"><a href="#race的用法：谁跑的快，以谁为准执行回调" class="headerlink" title="race的用法：谁跑的快，以谁为准执行回调"></a>race的用法：谁跑的快，以谁为准执行回调</h3><p>race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//请求某个图片资源</span>   <span class="token keyword">function</span> <span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>           <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token function">resolve</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'图片的路径'</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> p<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//延时函数，用于给请求计时</span>   <span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>           <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>               <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'图片请求超时'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> p<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requestImg函数会异步请求一张图片，我把地址写为”图片的路径”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16376a95ffa3b13c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Promise？我们用Promise来解决什么问题？&quot;&gt;&lt;a href=&quot;#什么是Promise？我们用Promise来解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;什么是Promise？我们用Promise来解决什么问题？&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="http://example.com/2022/02/21/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/02/21/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-21T06:47:05.000Z</published>
    <updated>2022-02-21T07:34:52.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="默认绑定规则"><a href="#默认绑定规则" class="headerlink" title="默认绑定规则"></a>默认绑定规则</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="隐式绑定规则"><a href="#隐式绑定规则" class="headerlink" title="隐式绑定规则"></a>隐式绑定规则</h2><p>谁调用就指向谁（隐式丢失 参数赋值）</p><h2 id="显式绑定规则"><a href="#显式绑定规则" class="headerlink" title="显式绑定规则"></a>显式绑定规则</h2><ul><li>call</li><li>apply</li><li>bind</li></ul><h2 id="new绑定规则"><a href="#new绑定规则" class="headerlink" title="new绑定规则"></a>new绑定规则</h2><p>实例化之后的对象</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数没有this指向，会向父级作用域查找</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;默认绑定规则&quot;&gt;&lt;a href=&quot;#默认绑定规则&quot; class=&quot;headerlink&quot; title=&quot;默认绑定规则&quot;&gt;&lt;/a&gt;默认绑定规则&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-js&quot; data-language=&quot;js&quot;&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
