<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chancerain</title>
  
  <subtitle>小而美的Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-17T05:58:15.507Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chancerain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数</title>
    <link href="http://example.com/2022/02/17/%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/02/17/%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-17T05:53:53.000Z</published>
    <updated>2022-02-17T05:58:15.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call() apply()"></a>call() apply()</h2><p>这两个方法都是函数对象的方法需要通过函数对象来调用<br>通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this<br>不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments和this类似，都是函数中的隐含的参数<br>arguments是一个类数组元素，它用来封装函数执行过程中的实参。所以即使不定义形参，也可以通过arguments来使用实参<br>arguments中有一个属性callee表示当前执行的函数对象</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象</p><ol><li>以函数的形式调用时，this是window</li><li>以方法的形式调用时，this是调用方法的对象</li><li>以构造函数的形式调用时，this是新建的那个对象</li><li>使用call和apply调用时，this是指定的那个对象</li><li>在全局作用域中this代表window</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;call-apply&quot;&gt;&lt;a href=&quot;#call-apply&quot; class=&quot;headerlink&quot; title=&quot;call() apply()&quot;&gt;&lt;/a&gt;call() apply()&lt;/h2&gt;&lt;p&gt;这两个方法都是函数对象的方法需要通过函数对象来调用&lt;br&gt;通</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2022/02/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/02/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-17T04:42:08.000Z</published>
    <updated>2022-02-17T05:53:39.837Z</updated>
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="http://example.com/2022/02/17/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/02/17/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-17T03:54:58.000Z</published>
    <updated>2022-02-17T05:51:30.651Z</updated>
    
    <content type="html"><![CDATA[<p>​        构造函数是专门用来创建对象的函数，一个构造函数我们也可以称为一个类。通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例。通过同一个构造函数创建的对象，我们称为一类对象</p><p>​        构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数，如果使用new来调用，则它就是一个构造函数</p><pre class=" language-js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><h2 id="构造函数的执行流程"><a href="#构造函数的执行流程" class="headerlink" title="构造函数的执行流程"></a>构造函数的执行流程</h2><ol><li>创建一个新的对象</li><li>将新的对象作为函数的上下文对象（this）</li><li>执行函数中的代码</li><li>将新建的对象返回</li></ol><p>instanceof 用来检查一个对象是否是一个类的实例，Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true</p><h2 id="枚举对象中的属性"><a href="#枚举对象中的属性" class="headerlink" title="枚举对象中的属性"></a>枚举对象中的属性</h2><p>for…in</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> 属性名 <span class="token keyword">in</span> 对象<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>for…in语句的循环体会执行多次，对象中有几个属性就会执行几次，每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性</p><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul><li><p>push()</p></li><li><p>pop()</p></li><li><p>unshift()</p><p>向数组的前边添加一个或多个元素，并返回数组的新的长度</p></li><li><p>shift()</p><p>删除数组的前边的一个元素，并返回被删除的元素</p></li><li><p>slice()</p><p>可以从一个数组中截取指定的元素。该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回</p><p>参数：</p><ol><li>截取开始位置的索引（包括开始位置）</li><li>截取结束位置的索引（不包括结束位置）</li></ol><p>第二个参数可以省略不写，如果不写则一直截取到最后；参数可以传递一个负值，如果是负值，则从后往前数</p></li><li><p>splice()</p><p>可以用来删除数组中指定元素，并使用新的元素替换；该方法会将删除的元素封装到新数组中返回</p><p>参数：</p><ol><li>删除开始位置的索引</li><li>删除的个数</li><li>三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边</li></ol></li><li><p>reverse()</p></li><li><p>concat()</p><p>可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回</p></li><li><p>join()</p><p>可以将一个数组转换为一个字符串</p><p>参数：</p><p>需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素如果不指定连接符则默认使用,</p></li><li><p>sort()</p><p>可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序。调用以后，会直接修改原数组。</p><p>可以自己指定排序的规则，需要一个回调函数作为参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//升序排列</span>                <span class="token comment" spellcheck="true">//return a-b;</span>                  <span class="token comment" spellcheck="true">//降序排列</span>                <span class="token keyword">return</span> b<span class="token operator">-</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><pre class=" language-js"><code class="language-js">数组<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value <span class="token punctuation">,</span> index <span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>数组中有几个元素，回调函数就会被调用几次</p><p>参数：</p><ol><li>value:正在遍历的元素</li><li>index:正在遍历元素的索引</li><li>obj:被遍历对象</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><ul><li><p>charAt()</p><p>根据索引获取指定的字符</p></li><li><p>indexOf()<br>lastIndexOf()</p><p>从一个字符串中检索指定内容</p><p>需要一个字符串作为参数，这个字符串就是要检索的内容，如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。</p><p>可以指定一个第二个参数，来表示开始查找的位置</p></li><li><p>slice()</p></li><li><p>substr()</p><p>和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，substring()中如果第二个参数小于第一个，自动调整位置</p></li><li><p>toLowerCase() </p></li><li><p>toUpperCase() </p></li><li><p>split()</p><p>可以根据指定内容将一个字符串拆分为一个数组</p><p>参数：</p><p>需要一个字符串作为参数，将会根据字符串去拆分数组。可以接收一个正则表达式，此时会根据正则表达式去拆分数组</p></li><li><p>match()</p><p>可以将字符串中和正则表达式匹配的内容提取出来<br>参数：<br>正则表达式，可以根据该正则表达式将字符串中符合要求的内容提取出来，并且封装到一个数组中返回</p></li><li><p>replace()</p><p>可以将字符串中指定内容替换为新的内容</p><p>参数：</p><ul><li>被替换的内容，可以是一个正则表达式</li><li>替换的新内容</li></ul></li><li><p>search()</p><p>可以根据正则表达式去字符串中查找指定的内容</p><p>参数：</p><p>正则表达式，将会根据该表达式查询内容，并且将第一个匹配到的内容的索引返回，如果没有匹配到任何内容，则返回-1</p></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建一个当前的时间对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建一个指定的时间对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"月/日/年 时:分:秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>getDate()</p></li><li><p>getDay()</p><p>返回当前日期对象时周几（0-6）</p></li><li><p>getMonth()</p></li><li><p>getFullYear()</p><p>从 Date 对象以四位数字返回年份</p></li><li><p>getHours()</p></li><li><p>getMinutes()</p></li><li><p>getSeconds()</p></li><li><p>getMilliseconds()</p><p>返回 Date 对象的毫秒(0 ~ 999)</p></li><li><p>getTime()</p><p>返回当前日期对象的时间戳</p></li><li><p>Date.now()</p><p>可以获取当前代码执行时的时间戳</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        构造函数是专门用来创建对象的函数，一个构造函数我们也可以称为一个类。通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例。通过同一个构造函数创建的对象，我们称为一类对象&lt;/p&gt;
&lt;p&gt;​        构造函数就是一个普通的函数，只是他的调用方式不</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型</title>
    <link href="http://example.com/2022/02/16/%E5%8E%9F%E5%9E%8B/"/>
    <id>http://example.com/2022/02/16/%E5%8E%9F%E5%9E%8B/</id>
    <published>2022-02-16T10:13:16.000Z</published>
    <updated>2022-02-17T04:16:06.934Z</updated>
    
    <content type="html"><![CDATA[<ul><li>创建一个函数以后，解析器都会默认在函数中添加一个数prototype，prototype属性指向的是一个对象，这个对象我们称为原型对象。</li><li>当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。这个隐含的属性可以通过对象_proto__来访问。</li><li>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。我们可以将对象中共有的属性和方法统一添加到原型对象中，这样我们只需要添加一次，就可以使所有的对象都可以使用。</li><li>当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，如果在自身中找到了，则直接使用。如果没有找到，则去原型对象中寻找，如果找到了则使用，如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null，如果依然没有找到则返回undefined</li><li>hasOwnProperty()<br>  - 这个方法可以用来检查对象自身中是否含有某个属性<br>  - 语法：对象.hasOwnProperty(“属性名”)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;创建一个函数以后，解析器都会默认在函数中添加一个数prototype，prototype属性指向的是一个对象，这个对象我们称为原型对象。&lt;/li&gt;
&lt;li&gt;当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。这个隐含的属性可以通过对象_p</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>作用域</title>
    <link href="http://example.com/2022/02/16/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2022/02/16/%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2022-02-16T10:11:31.000Z</published>
    <updated>2022-02-17T01:25:40.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><ul><li>全局作用域在打开页面时创建，在页面关闭时销毁</li><li>全局作用域中有一个全局对象window，window对象由浏览器提供，可以在页面中直接使用，它代表的是整个的浏览器的窗口</li><li>在全局作用域中创建的变量都会作为window对象的属性保存，在全局作用域中创建的函数都会作为window对象的方法保存</li><li>尽量不要在全局中创建变量</li></ul><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><ul><li>函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域</li><li>函数作用域在函数执行时创建，在函数执行结束时销毁。在函数作用域中创建的变量，不能在全局中访问</li><li>当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，如果找到了则使用，找不到则继续向上找</li></ul><h3 id="变量声明提前"><a href="#变量声明提前" class="headerlink" title="变量声明提前"></a>变量声明提前</h3><ul><li><p>在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。</p><ul><li>在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，如果没有使用var关键字声明变量，则变量会变成全局变量</li></ul></li></ul><h3 id="函数声明提前"><a href="#函数声明提前" class="headerlink" title="函数声明提前"></a>函数声明提前</h3><ul><li>在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun &#x3D; function(){})创建的函数没有该特性</li><li>在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了</li></ul><h2 id="this（上下文对象）"><a href="#this（上下文对象）" class="headerlink" title="this（上下文对象）"></a>this（上下文对象）</h2><p>我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。</p><h3 id="this的不同的情况"><a href="#this的不同的情况" class="headerlink" title="this的不同的情况"></a>this的不同的情况</h3><ol><li>以函数的形式调用时，this是window</li><li>以方法的形式调用时，this就是调用方法的对象</li><li>以构造函数的形式调用时，this就是新创建的对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://example.com/2022/02/16/BOM/"/>
    <id>http://example.com/2022/02/16/BOM/</id>
    <published>2022-02-16T08:40:38.000Z</published>
    <updated>2022-02-16T09:50:10.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p>BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。</p><ul><li><p>Window</p><p>代表的是整个浏览器的窗口，同时window也是网页中的全局对象</p></li><li><p>Navigator</p><p>代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器</p></li><li><p>Location</p><p>代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面</p></li><li><p>History</p><p>代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，该操作只在当次访问时有效</p></li><li><p>Screen</p><p>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</p></li></ul><h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>一般我们只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent</p><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul><li>length</li><li>back()</li><li>forward()</li><li>go()</li></ul><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）；如果直接将location属性修改为一个完整的路径，或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录</p><ul><li><p>assign()</p><p>用来跳转到其他的页面，作用和直接修改location一样</p></li><li><p>reload()</p><p>用于重新加载当前页面，作用和刷新按钮一样</p><p>如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</p></li><li><p>replace()</p><p>可以使用一个新的页面替换当前页面，调用完毕也会跳转页面</p><p>不会生成历史记录，不能使用回退按钮回退</p></li></ul><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时调用"><a href="#定时调用" class="headerlink" title="定时调用"></a>定时调用</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           count<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>clearInterval() 可以用来关闭一个定时器，方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器</p><p>clearInterval(timer);</p><h3 id="延时调用"><a href="#延时调用" class="headerlink" title="延时调用"></a>延时调用</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用clearTimeout()来关闭一个延时调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BOM对象&quot;&gt;&lt;a href=&quot;#BOM对象&quot; class=&quot;headerlink&quot; title=&quot;BOM对象&quot;&gt;&lt;/a&gt;BOM对象&lt;/h2&gt;&lt;p&gt;BOM对象在浏览器中作为window对象的属性保存，可以通过window对象来使用，也可以直接使用。&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="http://example.com/2022/02/16/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2022/02/16/%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-02-16T08:01:34.000Z</published>
    <updated>2022-02-16T08:31:28.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><ol><li><p>通过DOM对象指定的属性来绑定</p><pre class=" language-js"><code class="language-js">btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span> <span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>通过HTML元素指定事件属性来绑定</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。</li></ul><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><ul><li>事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。</li><li>可以将事件对象的cancelBubble设置为true，即可取消冒泡</li></ul><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.bbsxiaomi.com/images/202110/1634211541116099.png" alt="事件的传播_捕获|目标|冒泡阶段的说明及转换_事件委托/事件代理_原生JS-小米技术社区"></p><ol><li><p>捕获阶段 </p><p>这一阶段会从window对象开始向下一直遍历到目标对象，如果发现有对 象绑定了响应事件则做相应的处理。</p></li><li><p>目标阶段<br>这一阶段已经遍历结束，则会执行目标对象上绑定的响应函数。 </p></li><li><p>事件冒泡阶段<br>这一阶段，事件的传播方式和捕获阶段正好相反，会从事件目标一直向 上遍历，直至window对象结束，这时对象上绑定的响应函数也会执行。</p></li></ol><ul><li><p>取消传播</p><ul><li><p>我们可以使用event对象的两个方法完成：</p><p>stopPropagation()</p><p>stopImmediatePropagation() </p></li><li><p>取消默认行为： </p><p>preventDefault()</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件处理程序&quot;&gt;&lt;a href=&quot;#事件处理程序&quot; class=&quot;headerlink&quot; title=&quot;事件处理程序&quot;&gt;&lt;/a&gt;事件处理程序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过DOM对象指定的属性来绑定&lt;/p&gt;
&lt;pre class=&quot; language-js&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node</title>
    <link href="http://example.com/2022/02/14/Node/"/>
    <id>http://example.com/2022/02/14/Node/</id>
    <published>2022-02-14T07:25:19.000Z</published>
    <updated>2022-02-16T10:24:39.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建最基本的web服务器"><a href="#创建最基本的web服务器" class="headerlink" title="创建最基本的web服务器"></a>创建最基本的web服务器</h2><h3 id="创建web服务器的基本步骤"><a href="#创建web服务器的基本步骤" class="headerlink" title="创建web服务器的基本步骤"></a>创建web服务器的基本步骤</h3><ol><li>导入 http 模块</li><li>创建 web 服务器实例</li><li>为服务器实例绑定 <strong>request</strong> 事件，监听客户端的请求</li><li>启动服务器</li></ol><h3 id="导入http模块"><a href="#导入http模块" class="headerlink" title="导入http模块"></a>导入http模块</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建最基本的web服务器&quot;&gt;&lt;a href=&quot;#创建最基本的web服务器&quot; class=&quot;headerlink&quot; title=&quot;创建最基本的web服务器&quot;&gt;&lt;/a&gt;创建最基本的web服务器&lt;/h2&gt;&lt;h3 id=&quot;创建web服务器的基本步骤&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Node.js" scheme="http://example.com/categories/Node-js/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Node.js" scheme="http://example.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://example.com/2022/02/14/DOM/"/>
    <id>http://example.com/2022/02/14/DOM/</id>
    <published>2022-02-13T22:55:42.000Z</published>
    <updated>2022-02-14T03:02:47.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><h3 id="通过具体的元素节点来查询"><a href="#通过具体的元素节点来查询" class="headerlink" title="通过具体的元素节点来查询"></a>通过具体的元素节点来查询</h3><ul><li>element.getElementsByTagName()</li><li>element.childNodes</li><li>element.firstChild</li><li>element.lastChild</li><li>element.parentNode</li><li>element.previousSibling</li><li>element.nextSibling</li></ul><h3 id="document对象的其他的属性和方法"><a href="#document对象的其他的属性和方法" class="headerlink" title="document对象的其他的属性和方法"></a>document对象的其他的属性和方法</h3><ul><li>document.all</li><li>document.documentElement</li><li>document.body</li><li>document.getElementsByClassName()</li><li>document.querySelector()<ul><li>返回第一个元素</li></ul></li><li>document.querySelectorAll()<ul><li>返回数组</li></ul></li></ul><h2 id="DOM对CSS的操作"><a href="#DOM对CSS的操作" class="headerlink" title="DOM对CSS的操作"></a>DOM对CSS的操作</h2><h3 id="读取修改内联样式"><a href="#读取修改内联样式" class="headerlink" title="读取修改内联样式"></a>读取修改内联样式</h3><h4 id="读取内联样式"><a href="#读取内联样式" class="headerlink" title="读取内联样式"></a>读取内联样式</h4><ul><li>element.style.styleName</li></ul><h4 id="修改内联样式"><a href="#修改内联样式" class="headerlink" title="修改内联样式"></a>修改内联样式</h4><ul><li>element.style.styleName &#x3D; value</li></ul><h3 id="其他样式相关属性"><a href="#其他样式相关属性" class="headerlink" title="其他样式相关属性"></a>其他样式相关属性</h3><ol><li><p>clientHeight</p><ul><li>元素的可见高度，指元素的内容区和内边距的高度</li></ul></li><li><p>clientWidth</p><ul><li>元素的可见宽度，指元素的内容区和内边距的宽度</li></ul></li><li><p>offsetHeight</p><ul><li>整个元素的高度，包括内容区、内边距、边框</li></ul></li><li><p>offfsetWidth</p><ul><li>整个元素的宽度，包括内容区、内边距、边框</li></ul></li><li><p>offsetParent</p><ul><li><p>当前元素的定位父元素</p></li><li><p>离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回body</p></li></ul></li><li><p>offsetLeft<br>offsetTop</p><ul><li>当前元素和定位父元素之间的偏移量</li><li>offsetLeft水平偏移量  offsetTop垂直偏移量</li></ul></li><li><p>scrollHeight<br>scrollWidth</p><ul><li>获取元素滚动区域的高度和宽度</li></ul></li><li><p>scrollTop<br>scrollLeft</p><ul><li>获取元素垂直和水平滚动条滚动的距离</li></ul></li></ol><blockquote><p>判断滚动条是否滚动到底</p><ul><li><p>垂直滚动条<br>scrollHeight - scrollTop &#x3D; clientHeight</p></li><li><p>水平滚动<br>scrollWidth - scrollLeft &#x3D; clientWidth</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DOM查询&quot;&gt;&lt;a href=&quot;#DOM查询&quot; class=&quot;headerlink&quot; title=&quot;DOM查询&quot;&gt;&lt;/a&gt;DOM查询&lt;/h2&gt;&lt;h3 id=&quot;通过具体的元素节点来查询&quot;&gt;&lt;a href=&quot;#通过具体的元素节点来查询&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="http://example.com/2022/02/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/02/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-02-13T22:50:13.000Z</published>
    <updated>2022-02-17T01:12:10.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JS中一共分成六种数据类型</p><ul><li>String 字符串</li><li>Number 数值</li><li>Boolean 布尔值</li><li>Null 空值</li><li>Undefined 未定义</li><li>Object 对象</li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p>String</p><p>在字符串中使用\作为转义字符<br>&#39;  &#x3D;&#x3D;&gt; ‘<br>&quot;  &#x3D;&#x3D;&gt; “<br>\n  &#x3D;&#x3D;&gt; 换行<br>\t  &#x3D;&#x3D;&gt; 制表符<br>\  &#x3D;&#x3D;&gt; \    </p></li><li><p>Number</p><p>特殊的数字<br>Infinity 正无穷<br>Infinity 负无穷<br>NaN 非法数字（Not A Number）<br>其他进制的数字的表示：<br>0b 开头表示二进制，但是不是所有的浏览器都支持<br>0 开头表示八进制<br>0x 开头表示十六进制</p></li><li><p>Boolean</p></li><li><p>Null</p></li><li><p>Undefined</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li><p>Object 对象</p><p>​    Function 函数</p><p>​    Array 数组</p></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="转换为String"><a href="#转换为String" class="headerlink" title="转换为String"></a>转换为String</h3><ul><li><p>方法一 (强制转换)</p><p>toString()</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个方法不适用于null和undefined，由于这两个类型的数据中没有方法，所以调用toString()时会报错</p></li><li><p>方法二 (强制转换)</p><p>String()</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对于Number Boolean String都会调用toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined”</p></li><li><p>方法三 (隐式转换)</p><p>任意的数据类型 +””</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span></code></pre><p>和String()函数一样</p></li></ul><h3 id="转换为Number"><a href="#转换为Number" class="headerlink" title="转换为Number"></a>转换为Number</h3><ul><li><p>方法一 (强制转换)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>转换的情况：</p><ol><li>字符串 –&gt; 数字<ul><li>如果字符串是一个合法的数字，则直接转换为对应的数字</li><li>如果字符串是一个非法的数字，则转换为NaN</li><li>如果是一个空串或纯空格的字符串，则转换为0</li></ul></li><li>布尔值 –&gt; 数字<ul><li>true转换为1</li><li>false转换为0</li></ul></li><li>空值 –&gt; 数字<ul><li>null转换为0</li></ul></li><li>未定义 –&gt; 数字<ul><li>undefined 转换为NaN</li></ul></li></ol></li><li><p>方法二 (强制转换)</p><p>parseInt()或parseFloat()</p><ul><li><p>parseInt()可以将一个字符串中的有效的整数位提取出来，并转换为Number</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"123.456px"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123</span></code></pre></li><li><p>parseFloat()可以将一个字符串中的有效的小数位提取出来，并转换为Number</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"123.456px"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123.456</span></code></pre></li></ul></li><li><p>方法三 (隐式转换)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token operator">+</span>a<span class="token punctuation">;</span></code></pre><p>和Number()函数一样</p></li></ul><h3 id="转换为Boolean"><a href="#转换为Boolean" class="headerlink" title="转换为Boolean"></a>转换为Boolean</h3><ul><li><p>方法一 (强制转换)</p><p>使用Boolean()函数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">"false"</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>转换的情况</p><ol><li><p>字符串 –&gt; 布尔</p><p>除了空串其余全是true</p></li><li><p>数值 –&gt; 布尔</p><p>除了0和NaN其余的全是true</p></li><li><p>null、undefined —&gt; 布尔</p><p>都是false</p></li><li><p>对象 —&gt; 布尔</p><p>都是true</p></li></ol></li><li><p>方法二 (隐式转换)</p><p>为任意的数据类型做两次非运算，即可将其转换为布尔值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;JS中一共分成六种数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 字符串&lt;/li&gt;
&lt;li&gt;Number 数值&lt;/li&gt;
</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS基础" scheme="http://example.com/categories/JavaScript/JS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://example.com/2022/02/13/Git/"/>
    <id>http://example.com/2022/02/13/Git/</id>
    <published>2022-02-13T06:57:52.000Z</published>
    <updated>2022-02-13T22:46:32.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见版本控制"><a href="#常见版本控制" class="headerlink" title="常见版本控制"></a>常见版本控制</h2><h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><ul><li>集中版本控制  SVN<ul><li>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。</li></ul></li><li>分布版本控制 Git<ul><li>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。不会因为服务器损坏或者网络问题，造成不能工作的情况！</li></ul></li></ul><h3 id="Git和SVN的主要区别"><a href="#Git和SVN的主要区别" class="headerlink" title="Git和SVN的主要区别"></a>Git和SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h2 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h2><h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>git的工作流程一般是这样的：</p><ol><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到git仓库。</p></li></ol><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7210655b4d4fc4afcd1466d9aa2343~tplv-k3u1fbpfcp-watermark.awebp" alt="git"></p><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h2><h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ol><li>创建全新的仓库，需要用GIT管理的项目的根目录执行：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init</code></pre><ol start="2"><li>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</li></ol><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><ul><li>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆一个项目和它的整个代码历史(版本信息)</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span>  </code></pre><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><h3 id="Git分支常用指令"><a href="#Git分支常用指令" class="headerlink" title="Git分支常用指令"></a>Git分支常用指令</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span><span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见版本控制&quot;&gt;&lt;a href=&quot;#常见版本控制&quot; class=&quot;headerlink&quot; title=&quot;常见版本控制&quot;&gt;&lt;/a&gt;常见版本控制&lt;/h2&gt;&lt;h3 id=&quot;版本控制分类&quot;&gt;&lt;a href=&quot;#版本控制分类&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="杂" scheme="http://example.com/categories/%E6%9D%82/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
</feed>
