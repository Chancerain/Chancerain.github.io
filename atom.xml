<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chancerain</title>
  
  <subtitle>小而美的Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-25T05:05:54.851Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chancerain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02 CSS样式表和选择器</title>
    <link href="http://example.com/2022/02/25/02%20CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://example.com/2022/02/25/02%20CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E5%92%8C%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2022-02-25T04:58:48.000Z</published>
    <updated>2022-02-25T05:05:54.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-和-HTML-结合的方式（样式表）"><a href="#CSS-和-HTML-结合的方式（样式表）" class="headerlink" title="CSS 和 HTML 结合的方式（样式表）"></a>CSS 和 HTML 结合的方式（样式表）</h2><p>CSS 和 HTML 的结合方式有 3 种：</p><ul><li><strong>行内样式</strong>：在某个特定的标签里采用 style<strong>属性</strong>。范围只针对此标签。</li><li><strong>内嵌样式表</strong>：在页面的 head 里采用<code>&lt;style&gt;</code><strong>标签</strong>。范围针对此页面。</li><li><strong>引入外部样式表 css 文件</strong>的方式。这种引入方式又分为两种： - 1、采用<code>&lt;link&gt;</code>标签。例如：<code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt;</code> - 2、采用 import，必须写在<code>&lt;style&gt;</code>标签中，并且必须是第一句。例如：<code>@import url(a.css) ;</code></li></ul><blockquote><p>两种引入样式方式的区别：外部样式表中不能写标签，但是可以写 import 语句。</p></blockquote><h2 id="CSS-的四种基本选择器"><a href="#CSS-的四种基本选择器" class="headerlink" title="CSS 的四种基本选择器"></a>CSS 的四种基本选择器</h2><p>CSS 的选择器分为两大类：基本选择题和扩展选择器。</p><p> <strong>基本选择器：</strong></p><ul><li>标签选择器：针对<strong>一类</strong>标签</li><li>ID 选择器：针对某<strong>一个</strong>特定的标签使用</li><li>类选择器：针对<strong>你想要的所有</strong>标签使用</li><li>通用选择器（通配符）：针对所有的标签都适用（不建议使用）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS-和-HTML-结合的方式（样式表）&quot;&gt;&lt;a href=&quot;#CSS-和-HTML-结合的方式（样式表）&quot; class=&quot;headerlink&quot; title=&quot;CSS 和 HTML 结合的方式（样式表）&quot;&gt;&lt;/a&gt;CSS 和 HTML 结合的方式（样式表）&lt;/</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>02 背景属性</title>
    <link href="http://example.com/2022/02/25/02%20%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2022/02/25/02%20%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-25T04:57:16.000Z</published>
    <updated>2022-02-25T04:58:30.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="background-的常见背景属性"><a href="#background-的常见背景属性" class="headerlink" title="background 的常见背景属性"></a>background 的常见背景属性</h2><ul><li><code>background-color:#ff99ff;</code> 设置元素的背景颜色。</li><li><code>background-image:url(images/2.gif);</code> 将图像设置为背景。</li><li><code>background-repeat: no-repeat;</code> 设置背景图片是否重复及如何重复，默认平铺满。（重要）<ul><li><code>no-repeat</code>不要平铺；</li><li><code>repeat-x</code>横向平铺；</li><li><code>repeat-y</code>纵向平铺。</li></ul></li><li><code>background-position:center top;</code> 设置背景图片在当前容器中的位置。</li><li><code>background-attachment:scroll;</code> 设置背景图片是否跟着滚动条一起移动。 属性值可以是：<code>scroll</code>（与fixed属性相反，默认属性）、<code>fixed</code>（背景就会被固定住，不会被滚动条滚走）。</li><li>另外还有一个综合属性叫做<code>background</code>，它的作用是：将上面的多个属性写在一个声明中。</li></ul><p><strong>CSS3</strong> 中，新增了一些background属性：</p><ul><li>background-origin</li><li>background-clip 背景裁切</li><li>background-size 调整尺寸</li><li>多重背景</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;background-的常见背景属性&quot;&gt;&lt;a href=&quot;#background-的常见背景属性&quot; class=&quot;headerlink&quot; title=&quot;background 的常见背景属性&quot;&gt;&lt;/a&gt;background 的常见背景属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>字体属性和文本属性</title>
    <link href="http://example.com/2022/02/24/01%20%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2022/02/24/01%20%E5%AD%97%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7/</id>
    <published>2022-02-24T08:37:58.000Z</published>
    <updated>2022-02-25T04:56:59.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS的单位"><a href="#CSS的单位" class="headerlink" title="CSS的单位"></a>CSS的单位</h2><h3 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h3><p>1 <code>in</code>&#x3D;2.54<code>cm</code>&#x3D;25.4<code>mm</code>&#x3D;72<code>pt</code>&#x3D;6<code>pc</code>。</p><p>各种单位的含义：</p><ul><li><code>in</code>：英寸Inches (1 英寸 &#x3D; 2.54 厘米)</li><li><code>cm</code>：厘米Centimeters</li><li><code>mm</code>：毫米Millimeters</li><li><code>pt</code>：点Points，或者叫英镑 (1点 &#x3D; 1&#x2F;72英寸)</li><li><code>pc</code>：皮卡Picas (1 皮卡 &#x3D; 12 点)</li></ul><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p><code>px</code>：像素 <code>em</code>：印刷单位相当于12个点 <code>%</code>：百分比，相对周围的文字的大小</p><h2 id="font-字体属性"><a href="#font-字体属性" class="headerlink" title="font 字体属性"></a>font 字体属性</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span><span class="token punctuation">&#123;</span><span class="token property">font-size</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span> <span class="token comment">/*字体大小*/</span><span class="token property">line-height</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>      <span class="token comment">/*行高*/</span><span class="token property">font-family</span><span class="token punctuation">:</span> 幼圆<span class="token punctuation">,</span>黑体<span class="token punctuation">;</span> <span class="token comment">/*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/</span><span class="token property">font-style</span><span class="token punctuation">:</span> italic <span class="token punctuation">;</span><span class="token comment">/*italic表示斜体，normal表示不倾斜*/</span><span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span><span class="token comment">/*粗体*/</span><span class="token property">font-variant</span><span class="token punctuation">:</span> small-caps<span class="token punctuation">;</span>  <span class="token comment">/*小写变大写*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>CSS样式中，常见的文本属性有以下几种：</p><ul><li><code>letter-spacing: 0.5cm ;</code> 单个字母之间的间距</li><li><code>word-spacing: 1cm;</code> 单词之间的间距</li><li><code>text-decoration: none;</code> 字体修饰：none 去掉下划线、<strong>underline 下划线</strong>、line-through 中划线、overline 上划线</li><li><code>text-transform: lowercase;</code> 单词字体大小写。uppercase大写、lowercase小写</li><li><code>color:red;</code> 字体颜色</li><li><code>text-align: center;</code> 在当前容器中的对齐方式。属性值可以是：left、right、center（<strong>在当前容器的中间</strong>）、justify</li><li><code>text-transform: lowercase;</code> 单词的字体大小写。属性值可以是：<code>uppercase</code>（单词大写）、<code>lowercase</code>（单词小写）、<code>capitalize</code>（每个单词的首字母大写）</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-18.png" alt="img"></p><h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">ul li</span><span class="token punctuation">&#123;</span><span class="token property">list-style-image</span><span class="token punctuation">:</span><span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>images/2.gif<span class="token punctuation">)</span></span> <span class="token punctuation">;</span>  <span class="token comment">/*列表项前设置为图片*/</span><span class="token property">margin-left</span><span class="token punctuation">:</span>80px<span class="token punctuation">;</span>  <span class="token comment">/*公有属性*/</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/2015-10-03-css-26.png" alt="img"></p><h2 id="overflow属性：超出范围的内容要怎么处理"><a href="#overflow属性：超出范围的内容要怎么处理" class="headerlink" title="overflow属性：超出范围的内容要怎么处理"></a>overflow属性：超出范围的内容要怎么处理</h2><p><code>overflow</code>属性的属性值可以是：</p><ul><li><code>visible</code>：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。</li><li><code>hidden</code>：不显示超过对象尺寸的内容。</li><li><code>auto</code>：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。</li><li><code>scroll</code>：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 <code>auto</code> 属性相同。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSS的单位&quot;&gt;&lt;a href=&quot;#CSS的单位&quot; class=&quot;headerlink&quot; title=&quot;CSS的单位&quot;&gt;&lt;/a&gt;CSS的单位&lt;/h2&gt;&lt;h3 id=&quot;绝对单位&quot;&gt;&lt;a href=&quot;#绝对单位&quot; class=&quot;headerlink&quot; title=&quot;绝</summary>
      
    
    
    
    <category term="CSS" scheme="http://example.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/2022/02/24/HTML/"/>
    <id>http://example.com/2022/02/24/HTML/</id>
    <published>2022-02-24T08:37:50.000Z</published>
    <updated>2022-02-25T04:32:35.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特殊字符（转义字符）"><a href="#特殊字符（转义字符）" class="headerlink" title="特殊字符（转义字符）"></a>特殊字符（转义字符）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/3533a024e850b5b8.png"></p><h2 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5"></a>什么是 HTML5</h2><p>HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它<strong>制定了Web应用开发的一系列标准</strong>，成为第一个将Web做为应用开发平台的HTML语言。</p><p>HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。</p><p><strong><code>HTML5</code>的广义概念</strong>：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。</p><p><code>HTML5</code>不等于 <code>HTML next version</code>。<code>HTML5</code> 包含： <code>HTML</code>的升级版、<code>CSS</code>的升级版、<code>JavaScript API</code>的升级版。</p><p><strong>总结</strong>：<code>HTML5</code>是新一代开发 <strong>Web 富客户端</strong>应用程序整体<strong>解决方案</strong>。包括：HTML5，CSS3，Javascript API在内的一套<strong>技术组合</strong>。</p><p><strong>富客户端</strong>：具有很强的<strong>交互性</strong>和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。</p><h2 id="HTML5-新增的内容"><a href="#HTML5-新增的内容" class="headerlink" title="HTML5 新增的内容"></a>HTML5 新增的内容</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1540.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1545.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1541.png" alt="img"></p><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><h3 id="语义化的作用"><a href="#语义化的作用" class="headerlink" title="语义化的作用"></a>语义化的作用</h3><p>语义标签对于我们并不陌生，如<code>&lt;p&gt;</code>表示一个段落、<code>&lt;ul&gt;</code>表示一个无序列表。<strong>标签语义化的作用：</strong></p><ul><li>能够便于开发者阅读和写出更优雅的代码。</li><li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。</li><li>更好地搜索引擎优化。</li></ul><h3 id="H5在语义上的改进"><a href="#H5在语义上的改进" class="headerlink" title="H5在语义上的改进"></a>H5在语义上的改进</h3><p>HTML：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1546.png" alt="img"></p><p>HTML 5：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180206_1550.png" alt="img"></p><p><strong>传统网页布局：</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 头部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 主体部分 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 文章 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 侧边栏 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aside<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 底部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>H5 的经典网页布局：</strong></p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 头部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 主体部分 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 文章 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 侧边栏 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aside</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 底部 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;section&gt;</code> 表示区块</li><li><code>&lt;article&gt;</code> 表示文章。如文章、评论、帖子、博客</li><li><code>&lt;header&gt;</code> 表示页眉</li><li><code>&lt;footer&gt;</code> 表示页脚</li><li><code>&lt;nav&gt;</code> 表示导航</li><li><code>&lt;aside&gt;</code> 表示侧边栏。如文章的侧栏</li><li><code>&lt;figure&gt;</code> 表示媒介内容分组。</li><li><code>&lt;mark&gt;</code> 表示标记 (用得少)</li><li><code>&lt;progress&gt;</code> 表示进度 (用得少)</li><li><code>&lt;time&gt;</code> 表示日期</li></ul><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li>document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。</li><li>document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。</li></ul><h3 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a>类名操作</h3><ul><li>Node.classList.add(“class”) 添加class</li><li>Node.classList.remove(“class”) 移除class</li><li>Node.classList.toggle(“class”) 切换class，有则移除，无则添加</li><li>Node.classList.contains(“class”) 检测是否存在class</li></ul><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>js 里可以通过 <code>box1.index=100;</code> <code>box1.title</code> 来自定义属性和获取属性。</p><p>H5可以直接在标签里添加自定义属性，<strong>但必须以 <code>data-</code> 开头</strong>。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 给标签添加自定义属性 必须以data-开头 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>盒子<span class="token punctuation">"</span></span> <span class="token attr-name">data-my-name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>smyhvae<span class="token punctuation">"</span></span> <span class="token attr-name">data-content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>我是一个div<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>div<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//自定义的属性 需要通过 dateset[]方式来获取</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"content"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印结果：我是一个div</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"myName"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//打印结果：smyhvae</span>    <span class="token comment">//设置自定义属性的值</span>    <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    num<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    box<span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    box<span class="token punctuation">.</span>dataset<span class="token punctuation">[</span><span class="token string">"content"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"aaaa"</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。</p><p>在HTML5中可以通过 <code>window.history</code> 操作访问历史状态，让一个页面可以有多个历史状态</p><p><code>window.history</code>对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。</p><ul><li>window.history.forward(); &#x2F;&#x2F; 前进</li><li>window.history.back(); &#x2F;&#x2F; 后退</li><li>window.history.go(); &#x2F;&#x2F; 刷新</li><li>window.history.go(n); &#x2F;&#x2F;n&#x3D;1 表示前进；n&#x3D;-1 后退；n&#x3D;0s 刷新。如果移动的位置超出了访问历史的边界，会静默失败，但不会报错。</li><li>通过JS可以加入一个访问状态</li><li>history.pushState; &#x2F;&#x2F;放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态)</li></ul><h2 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h2><p>在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即<strong>基于位置服务 LBS</strong> (Location Base Service)。</p><h3 id="API详解"><a href="#API详解" class="headerlink" title="API详解"></a>API详解</h3><ul><li>navigator.getCurrentPosition(successCallback, errorCallback, options) 获取当前地理信息</li><li>navigator.watchPosition(successCallback, errorCallback, options) 重复获取当前地理信息</li></ul><p>1、当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标）</p><ul><li>position.coords.latitude纬度</li><li>position.coords.longitude经度</li></ul><p>2、当获取地理信息失败后，会调用errorCallback，并返回错误信息error。</p><p>3、可选参数 options 对象可以调整位置信息数据收集方式</p><h2 id="Web-存储"><a href="#Web-存储" class="headerlink" title="Web 存储"></a>Web 存储</h2><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以document.cookie来进行存储的，但是由于其存储大小只有4k左右，并且解析也相当的复杂，给开发带来诸多不便，HTML5规范则提出解决方案。</p><h3 id="H5-中有两种存储的方式"><a href="#H5-中有两种存储的方式" class="headerlink" title="H5 中有两种存储的方式"></a>H5 中有两种存储的方式</h3><p>1、**<code>window.sessionStorage</code> 会话存储：**</p><ul><li>保存在内存中。</li><li><strong>生命周期</strong>为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。</li><li>在同一个窗口下数据可以共享。</li></ul><p>2、**<code>window.localStorage</code> 本地存储**：</p><ul><li>有可能保存在浏览器内存里，有可能在硬盘里。</li><li>永久生效，除非手动删除（比如清理垃圾的时候）。</li><li>可以多窗口共享。</li></ul><h3 id="Web-存储的特性"><a href="#Web-存储的特性" class="headerlink" title="Web 存储的特性"></a>Web 存储的特性</h3><p>（1）设置、读取方便。</p><p>（2）容量较大，sessionStorage 约5M、localStorage 约20M。</p><p>（3）只能存储字符串，可以将对象 JSON.stringify() 编码后存储。</p><h3 id="常见-API"><a href="#常见-API" class="headerlink" title="常见 API"></a>常见 API</h3><p>设置存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS：可以新增一个 item，也可以更新一个 item。</p><p>读取存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据键，删除存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">removeItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清空所有存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据索引值来获取存储内容：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">key</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="html-元素的分类"><a href="#html-元素的分类" class="headerlink" title="html 元素的分类"></a>html 元素的分类</h2><h3 id="按照样式分类："><a href="#按照样式分类：" class="headerlink" title="按照样式分类："></a>按照样式分类：</h3><ul><li>块级元素</li><li>行内元素</li><li>inline-block：比如<code>form</code>表单元素。对外的表现是行内元素（不会独占一行），对内的表现是块级元素（可以设置宽高）。</li></ul><h2 id="html常见面试题"><a href="#html常见面试题" class="headerlink" title="html常见面试题"></a>html常见面试题</h2><h3 id="HTML、XHTML、HTML5的区别"><a href="#HTML、XHTML、HTML5的区别" class="headerlink" title="HTML、XHTML、HTML5的区别"></a>HTML、XHTML、HTML5的区别</h3><ul><li>HTML 属于 SGML</li><li>XHTML 属于 XML，是 HTML 进行 XML 严格化的结果</li><li>HTML5 不属于SGML，也不属于 XML（HTML5有自己独立的一套规范），比 XHTML 宽松。</li></ul><h3 id="HTML5-有什么新的变化"><a href="#HTML5-有什么新的变化" class="headerlink" title="HTML5 有什么新的变化"></a>HTML5 有什么新的变化</h3><ul><li>新的语义化元素</li><li>表单增强</li><li>新的API：离线、音视频、图形、实时通信、本地存储、设备能力等。</li></ul><h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul><li>开发者容易理解，便于维护。</li><li>机器（搜索引擎、读屏软件等）容易理解结构</li><li>有助于 SEO</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;特殊字符（转义字符）&quot;&gt;&lt;a href=&quot;#特殊字符（转义字符）&quot; class=&quot;headerlink&quot; title=&quot;特殊字符（转义字符）&quot;&gt;&lt;/a&gt;特殊字符（转义字符）&lt;/h2&gt;&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R0lGO</summary>
      
    
    
    
    <category term="HTML" scheme="http://example.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流</title>
    <link href="http://example.com/2022/02/23/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2022/02/23/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2022-02-23T12:48:57.000Z</published>
    <updated>2022-02-23T13:07:50.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> addBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">addOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'增加一个'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span>time</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> timer  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments    timer<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>time<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>addBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token function">debounce</span><span class="token punctuation">(</span>addOne<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">scrollTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'现在我触发了'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fun<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> t1 <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">//初始时间</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//当前时间</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t2 <span class="token operator">-</span> t1 <span class="token operator">></span> time<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>      t1 <span class="token operator">=</span> t2    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span><span class="token function">throttle</span><span class="token punctuation">(</span>scrollTest<span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;p&gt;n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-js</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="杂" scheme="http://example.com/categories/JavaScript/%E6%9D%82/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Async/Await</title>
    <link href="http://example.com/2022/02/23/Async-Await/"/>
    <id>http://example.com/2022/02/23/Async-Await/</id>
    <published>2022-02-23T11:44:15.000Z</published>
    <updated>2022-02-23T11:49:33.020Z</updated>
    
    <content type="html"><![CDATA[<p>ES7 提出的<code>async</code> 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。<br><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="async-函数返回一个-Promise-对象"><a href="#async-函数返回一个-Promise-对象" class="headerlink" title="async 函数返回一个 Promise 对象"></a><strong>async 函数返回一个 Promise 对象</strong></h3><p><code>async</code> 函数内部 return 返回的值。会成为 <code>then</code> 方法回调函数的参数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hello world</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>async</code> 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 <code>reject</code> 状态。抛出的错误而会被 <code>catch</code> 方法回调函数接收到。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span> <span class="token parameter">e</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="async-函数返回的-Promise-对象，必须等到内部所有的-await-命令的-Promise-对象执行完，才会发生状态改变"><a href="#async-函数返回的-Promise-对象，必须等到内部所有的-await-命令的-Promise-对象执行完，才会发生状态改变" class="headerlink" title="async 函数返回的 Promise 对象，必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变"></a><strong>async 函数返回的 Promise 对象，必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变</strong></h3><p>也就是说，只有当 <code>async</code> 函数内部的异步操作都执行完，才会执行 <code>then</code> 方法的回调。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">delay</span> <span class="token operator">=</span> <span class="token parameter">timeout</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">'done'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待6s后才输出 'done'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>正常情况下，await 命令后面跟着的是 Promise ，如果不是的话，也会被转换成一个 立即 resolve 的 Promise</strong><br>如下面这个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果返回的是 reject 的状态，则会被 <code>catch</code> 方法捕获。</p><h2 id="Async-函数的错误处理"><a href="#Async-函数的错误处理" class="headerlink" title="Async 函数的错误处理"></a>Async 函数的错误处理</h2><p><code>async</code> 函数的语法不难，难在错误处理上。<br>先来看下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这段 await 并没有执行</span><span class="token punctuation">&#125;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面所示，当 <code>async</code> 函数中只要一个 <code>await</code> 出现 reject 状态，则后面的 <code>await</code> 都不会被执行。<br><strong>解决办法</strong>：可以添加 <code>try/catch</code>。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 正确的写法</span><span class="token keyword">let</span> a<span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">correct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    a <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">correct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多个 <code>await</code> 则可以将其都放在 <code>try/catch</code> 中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES7 提出的&lt;code&gt;async&lt;/code&gt; 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。&lt;br&gt;&lt;code&gt;async&lt;/code&gt; 函数是 &lt;code&gt;Generator&lt;/code&gt; 函数的语法糖</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://example.com/2022/02/23/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2022/02/23/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-02-23T09:04:10.000Z</published>
    <updated>2022-02-23T11:09:17.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。</li><li>深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。</li></ul><p>拷贝引用的时候，是属于<strong>传址</strong>，而非<strong>传值</strong>。关于传值和传址的区别，是很基础的内容，详见《JavaScript 基础&#x2F;对象简介.md》这篇文章。</p><p>深拷贝会把对象里<strong>所有的数据</strong>重新复制到新的内存空间，是最彻底的拷贝。</p><h2 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h2><h3 id="用-for-in-实现浅拷贝（比较繁琐）"><a href="#用-for-in-实现浅拷贝（比较繁琐）" class="headerlink" title="用 for in 实现浅拷贝（比较繁琐）"></a>用 for in 实现浅拷贝（比较繁琐）</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'很厉害'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//  用 for in 将 obj1 的值拷贝给 obj2</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    obj2<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'永不止步'</span><span class="token punctuation">;</span> <span class="token comment">// 当修改 obj1 的第二层数据时，obj2的值也会被改变。所以  for in 是浅拷贝</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，<code>obj2.info</code> 属性，跟 <code>obj1.info</code>属性，<strong>它俩指向的是同一个堆内存地址</strong>。所以，当我修改 <code>obj1.info</code> 里的值之后，<code>obj2.info</code>的值也会被修改。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token literal-property property">obj2</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string-property property">"info"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"很厉害"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token literal-property property">obj2</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span><span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token string-property property">"info"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"永不止步"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="用-Object-assgin-实现浅拷贝（推荐的方式）"><a href="#用-Object-assgin-实现浅拷贝（推荐的方式）" class="headerlink" title="用 Object.assgin() 实现浅拷贝（推荐的方式）"></a>用 Object.assgin() 实现浅拷贝（推荐的方式）</h3><p>上面的 for in 方法做浅拷贝过于繁琐。ES6 给我们提供了新的语法糖，通过 <code>Object.assgin()</code> 可以实现<strong>浅拷贝</strong>。</p><p><code>Object.assgin()</code> 在日常开发中，使用得相当频繁，非掌握不可。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 语法1</span>obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assgin</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 语法2</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>目标对象<span class="token punctuation">,</span> 源对象<span class="token number">1</span><span class="token punctuation">,</span> 源对象<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释</strong>：将<code>obj1</code> 拷贝给 <code>obj2</code>。执行完毕后，obj2 的值会被更新。</p><p><strong>作用</strong>：将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。</p><p>从语法2中可以看出，Object.assign() 可以将多个“源对象”拷贝到“目标对象”中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 浅拷贝：把 obj1 拷贝给 obj2。如果 obj1 只有一层数据，那么，obj1 和 obj2 则互不影响</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'永不止步'</span><span class="token punctuation">;</span> <span class="token comment">// 由于 Object.assign() 只是浅拷贝，所以当修改 obj1 的第二层数据时，obj2 对应的值也会被改变。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2:'</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> myObj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 【写法1】浅拷贝：把 myObj 拷贝给 obj1</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 【写法2】浅拷贝：把 myObj 拷贝给 obj2</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址</span><span class="token keyword">const</span> obj31 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj32 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj31<span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">26</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">city</span><span class="token operator">:</span> <span class="token string">'shenzhen'</span><span class="token punctuation">,</span> <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj3<span class="token punctuation">,</span> obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 obj1、obj2的内容赋值给 obj3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;name: "qianguyihao", age: 28, city: "shenzhen"&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello world'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'许嵩'</span><span class="token punctuation">,</span>    <span class="token literal-property property">sex</span><span class="token operator">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 浅拷贝：把 obj1 赋值给 obj2。这一行，是关键代码。这行代码的返回值也是 obj2</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>    <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"qianguyihao"</span><span class="token punctuation">,</span>    <span class="token string-property property">"sex"</span><span class="token operator">:</span><span class="token string">"男"</span><span class="token punctuation">,</span>    <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">,</span>    <span class="token string-property property">"desc"</span><span class="token operator">:</span><span class="token string">"hello world"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h2><p>深拷贝其实就是将浅拷贝进行递归。</p><h3 id="用-for-in-递归实现深拷贝"><a href="#用-for-in-递归实现深拷贝" class="headerlink" title="用 for in 递归实现深拷贝"></a>用 for in 递归实现深拷贝</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'qianguyihao'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">28</span><span class="token punctuation">,</span>    <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>info<span class="token punctuation">.</span>desc <span class="token operator">=</span> <span class="token string">'github'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 方法：深拷贝</span><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">newObj<span class="token punctuation">,</span> oldObj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> oldObj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取属性值 oldObj[key]</span>        <span class="token keyword">let</span> item <span class="token operator">=</span> oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 判断这个值是否是数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 判断这个值是否是对象</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token function">deepCopy</span><span class="token punctuation">(</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 简单数据类型，直接赋值</span>            newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。&lt;/li&gt;
&lt;li&gt;深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="杂" scheme="http://example.com/categories/JavaScript/%E6%9D%82/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://example.com/2022/02/23/%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2022/02/23/%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-02-23T03:59:42.000Z</published>
    <updated>2022-02-23T11:55:59.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1400.png" alt="img"></p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180228_1505.jpg" alt="img"></p><ul><li>请求行：包括请求方法、请求的url、http协议及版本。</li><li>请求头：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。</li><li>请求体：数据部分。</li></ul><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180228_1510.jpg" alt="img"></p><ul><li>状态行：http协议及版本、状态码及状态描述。</li><li>响应头</li><li>空行</li><li>响应体</li></ul><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul><li>GET：获取资源</li><li>POST：传输资源</li><li>put：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获得报文首部</li></ul><p>HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p><p>get 和 post 比较常见。</p><p>put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</p><p>head 可能偶尔用的到。</p><h2 id="get-和-post的区别"><a href="#get-和-post的区别" class="headerlink" title="get 和 post的区别"></a>get 和 post的区别</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1415.png" alt="img"></p><p><strong>get是相对不隐私的，而post是相对隐私的</strong>。</p><ol><li>浏览器在回退时，get<strong>不会重新请求</strong>，但是post会重新请求。【重要】</li><li>get请求会被浏览器<strong>主动缓存</strong>，而post不会。【重要】</li><li>get请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。</li><li>get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。</li><li>get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。</li></ol><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><h3 id="http状态码分类"><a href="#http状态码分类" class="headerlink" title="http状态码分类"></a>http状态码分类</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1430.png" alt="img"></p><h3 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1431.png" alt="img"></p><h3 id="部分解释"><a href="#部分解释" class="headerlink" title="部分解释"></a>部分解释</h3><ul><li>206的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。</li><li>301：重定向（永久）。</li><li>302：重定向（临时）。</li><li>304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.smyhvae.com/20180306_1440.png" alt="img"></p><p>400和401用的不多。403指的是请求被拒绝。404指的是资源不存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP报文的组成部分&quot;&gt;&lt;a href=&quot;#HTTP报文的组成部分&quot; class=&quot;headerlink&quot; title=&quot;HTTP报文的组成部分&quot;&gt;&lt;/a&gt;HTTP报文的组成部分&lt;/h2&gt;&lt;p&gt;&lt;img src= &quot;data:image/gif;base64,R</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://example.com/2022/02/23/Ajax/"/>
    <id>http://example.com/2022/02/23/Ajax/</id>
    <published>2022-02-23T03:59:20.000Z</published>
    <updated>2022-02-23T11:54:54.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax入门和发送http请求"><a href="#Ajax入门和发送http请求" class="headerlink" title="Ajax入门和发送http请求"></a>Ajax入门和发送http请求</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>Ajax：Asynchronous Javascript And XML（异步 JavaScript 和 XML）。它并不是凭空出现的新技术，而是对于现有技术的结合。Ajax 的核心是 js 对象：<strong>XMLHttpRequest</strong>。</p><h4 id="Ajax-原理（发送-Ajax-请求的五个步骤）"><a href="#Ajax-原理（发送-Ajax-请求的五个步骤）" class="headerlink" title="Ajax 原理（发送 Ajax 请求的五个步骤）"></a>Ajax 原理（发送 Ajax 请求的五个步骤）</h4><p>一个完整的 HTTP 请求需要的是：</p><ul><li>请求的网址、请求方法 get&#x2F;post。</li><li>提交请求的内容数据、请求主体等。</li><li>接收响应回来的内容。</li></ul><p>发送 Ajax 请求的五个步骤：</p><ol><li>创建异步对象，即 XMLHttpRequest 对象。</li><li>使用 open 方法设置请求参数。<code>open(method, url, async)</code>。参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。</li><li>发送请求：<code>send()</code>。</li><li>注册事件：注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</li><li>服务端响应，获取返回的数据。</li></ol><h3 id="XMLHttpRequest-对象详解"><a href="#XMLHttpRequest-对象详解" class="headerlink" title="XMLHttpRequest 对象详解"></a>XMLHttpRequest 对象详解</h3><p>发送请求的方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> async<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数解释：</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul><p>另外还有个方法：（仅用于 POST 请求）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">send</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="POST-请求时注意"><a href="#POST-请求时注意" class="headerlink" title="POST 请求时注意"></a>POST 请求时注意</h3><p>如果想让 像 form 表单提交数据那样使用 POST 请求，就需要使用 XMLHttpRequest 对象的 setRequestHeader()方法 来添加 HTTP 头。然后在 send() 方法中添加想要发送的数据：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">xmlhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'ajax_test.php'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xmlhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'name=smyhvae&amp;age=27'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数。</p><p>readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化）</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul><p>status：</p><ul><li>200: “OK”。</li><li>404: 未找到页面。</li></ul><p>在 onreadystatechange 事件中，<strong>当 readyState 等于 4，且状态码为 200 时，表示响应已就绪</strong>。</p><h4 id="服务器响应的内容"><a href="#服务器响应的内容" class="headerlink" title="服务器响应的内容"></a>服务器响应的内容</h4><ul><li>responseText：获得字符串形式的响应数据。</li><li>responseXML：获得 XML 形式的响应数据。</li></ul><p>如果响应的是普通字符串，就使用 responseText；如果响应的是 XML，使用 responseXML。</p><h3 id="jQuery-中的-Ajax"><a href="#jQuery-中的-Ajax" class="headerlink" title="jQuery 中的 Ajax"></a>jQuery 中的 Ajax</h3><p>格式举例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'https://xxx.com/getUserInfo.php'</span><span class="token punctuation">,</span> <span class="token comment">// 接口的请求地址</span>    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token string">'name=fox&amp;age=18'</span><span class="token punctuation">,</span> <span class="token comment">// 请求参数</span>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token comment">//请求的方式</span>    <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接口请求成功时调用</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'接口请求成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">beforeSend</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 在发送请求之前调用,可以做一些验证之类的处理</span>    <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">argument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 接口请求失败时调用</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'接口请求失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ajax传输JSON"><a href="#Ajax传输JSON" class="headerlink" title="Ajax传输JSON"></a>Ajax传输JSON</h2><p>JSON(JavaScript Object Notation)：是 ECMAScript 的子集。作用是进行数据的交换。语法更为简洁，网络传输、机器解析都更为迅速。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 对象</span><span class="token punctuation">&#123;</span>  <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"fox"</span><span class="token punctuation">,</span>  <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"18"</span><span class="token punctuation">,</span>  <span class="token string-property property">"sex"</span><span class="token operator">:</span><span class="token string">"true"</span><span class="token punctuation">,</span>  <span class="token string-property property">"car"</span><span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">&#125;</span><span class="token comment">// 数组</span><span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>      <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小小胡"</span><span class="token punctuation">,</span>      <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"1"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>      <span class="token string-property property">"name"</span><span class="token operator">:</span><span class="token string">"小二胡"</span><span class="token punctuation">,</span>      <span class="token string-property property">"age"</span><span class="token operator">:</span><span class="token string">"2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON-字符串-lt-–-gt-JS-对象"><a href="#JSON-字符串-lt-–-gt-JS-对象" class="headerlink" title="JSON 字符串 &lt;–&gt; JS 对象"></a>JSON 字符串 &lt;–&gt; JS 对象</h3><p>JSON.parse()：将 JSON 字符串转化为 js 对象。例如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 将 JSON 字符串格式化为 js 对象</span><span class="token keyword">var</span> jsObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ajax<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>JSON.stringify()：将 JS 对象转化为 JSON 字符串。例如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> Obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'fox'</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    <span class="token literal-property property">skill</span><span class="token operator">:</span> <span class="token string">'撩妹'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将 js 对象格式化为 JSON 字符串</span><span class="token keyword">var</span> jsonStr <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>Obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ajax入门和发送http请求&quot;&gt;&lt;a href=&quot;#Ajax入门和发送http请求&quot; class=&quot;headerlink&quot; title=&quot;Ajax入门和发送http请求&quot;&gt;&lt;/a&gt;Ajax入门和发送http请求&lt;/h2&gt;&lt;h3 id=&quot;Ajax&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Ajax" scheme="http://example.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM与Diff算法</title>
    <link href="http://example.com/2022/02/22/%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/22/%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-22T14:07:16.000Z</published>
    <updated>2022-02-23T03:56:14.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p><code>虚拟DOM</code>是一个<code>对象</code>，一个什么样的对象呢？<strong>一个用来表示真实DOM的对象</strong></p><p>以下<code>真实DOM</code>：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"list"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>哈哈<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>呵呵<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span>嘿嘿<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的<code>虚拟DOM</code>为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> oldVDOM <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 旧虚拟DOM</span>        <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token comment">// 标签名</span>        <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 标签属性</span>            <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'list'</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// 标签子节点</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'哈哈'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'呵呵'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token punctuation">&#123;</span>                <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'嘿嘿'</span><span class="token punctuation">]</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0089a781a80244308472447b86cad21e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-07 下午10.24.17.png"></p><p>由上图，一看便知，肯定是第2种方式比较快，因为第1种方式中间还夹着一个<code>虚拟DOM</code>的步骤，所以<strong>虚拟DOM比真实DOM快</strong>这句话其实是错的，或者说是不严谨的。那正确的说法是什么呢？<strong>虚拟DOM算法操作真实DOM，性能高于直接操作真实DOM</strong>，<code>虚拟DOM</code>和<code>虚拟DOM算法</code>是两种概念。<code>虚拟DOM算法 = 虚拟DOM + Diff算法</code></p><h2 id="什么是Diff算法"><a href="#什么是Diff算法" class="headerlink" title="什么是Diff算法"></a>什么是Diff算法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c57a7b4e91a4a359474fb4c281f6d8e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-07 下午10.59.31.png"></p><p>总结：<strong>Diff算法是一种对比算法</strong>。对比两者是<code>旧虚拟DOM和新虚拟DOM</code>，对比出是哪个<code>虚拟节点</code>更改了，找出这个<code>虚拟节点</code>，并只更新这个虚拟节点所对应的<code>真实节点</code>，而不用更新其他数据没发生改变的节点，实现<code>精准</code>地更新真实DOM，进而<code>提高效率</code>。</p><ul><li><code>使用虚拟DOM算法的损耗计算</code>： 总损耗 &#x3D; 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</li><li><code>直接操作真实DOM的损耗计算</code>： 总损耗 &#x3D; 真实DOM完全增删改+（可能较多的节点）排版与重绘</li></ul><h2 id="Diff算法的原理"><a href="#Diff算法的原理" class="headerlink" title="Diff算法的原理"></a>Diff算法的原理</h2><h3 id="Diff同层对比"><a href="#Diff同层对比" class="headerlink" title="Diff同层对比"></a>Diff同层对比</h3><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>深度优先算法</code>。 时间复杂度:<code>O(n)</code></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca3d338e5a445ab80e40042c50ac79a~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.32.47.png"></p><h3 id="Diff对比流程"><a href="#Diff对比流程" class="headerlink" title="Diff对比流程"></a>Diff对比流程</h3><p><code>newVnode和oldVnode</code>：同层的新旧虚拟节点</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.49.38.png"></p><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>这个方法作用就是，对比当前同层的虚拟节点是否为同一种类型的标签<code>(同一类型的标准，下面会讲)</code>：</p><ul><li>是：继续执行<code>patchVnode方法</code>进行深层比对</li><li>否：没必要比对了，直接整个节点替换成<code>新虚拟节点</code></li></ul><p>来看看<code>patch</code>的核心原理代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 比较是否为一个类型的节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 是：继续进行深层比较</span>    <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 否</span>    <span class="token keyword">const</span> oldEl <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el <span class="token comment">// 旧虚拟节点的真实DOM节点</span>    <span class="token keyword">const</span> parentEle <span class="token operator">=</span> api<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>oldEl<span class="token punctuation">)</span> <span class="token comment">// 获取父节点</span>    <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span> <span class="token comment">// 创建新虚拟节点对应的真实DOM节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentEle <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      api<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> api<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oEl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 将新元素添加进父元素</span>      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>parentEle<span class="token punctuation">,</span> oldVnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span>  <span class="token comment">// 移除以前的旧元素节点</span>      <span class="token comment">// 设置null，释放内存</span>      oldVnode <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> newVnode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sameVnode方法"><a href="#sameVnode方法" class="headerlink" title="sameVnode方法"></a>sameVnode方法</h3><p>patch关键的一步就是<code>sameVnode方法判断是否为同一类型节点</code>，那问题来了，怎么才算是同一类型节点呢？这个<code>类型</code>的标准是什么呢？</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    oldVnode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token comment">// key值是否一样</span>    oldVnode<span class="token punctuation">.</span>tagName <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>tagName <span class="token operator">&amp;&amp;</span> <span class="token comment">// 标签名是否一样</span>    oldVnode<span class="token punctuation">.</span>isComment <span class="token operator">===</span> newVnode<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都为注释节点</span>    <span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment">// 是否都定义了data</span>    <span class="token function">sameInputType</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> newVnode<span class="token punctuation">)</span> <span class="token comment">// 当标签为input时，type必须是否相同</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="patchVnode方法"><a href="#patchVnode方法" class="headerlink" title="patchVnode方法"></a>patchVnode方法</h3><p>这个函数做了以下事情：</p><ul><li>找到对应的<code>真实DOM</code>，称为<code>el</code></li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是，那么直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点。</li><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，这一步很重要</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">patchVnode</span><span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> newVnode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> el <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>el <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>el <span class="token comment">// 获取真实DOM对象</span>  <span class="token comment">// 获取新旧虚拟节点的子节点数组</span>  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children<span class="token punctuation">,</span> newCh <span class="token operator">=</span> newVnode<span class="token punctuation">.</span>children  <span class="token comment">// 如果新旧虚拟节点是同一个对象，则终止</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> newVnode<span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token comment">// 如果新旧虚拟节点是文本节点，且文本不一样</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 则直接将真实DOM中文本更新为新虚拟节点的文本</span>    api<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> newVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 否则</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">&amp;&amp;</span> newCh <span class="token operator">&amp;&amp;</span> oldCh <span class="token operator">!==</span> newCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 新旧虚拟节点都有子节点，且子节点不一样</span>      <span class="token comment">// 对比子节点，并更新</span>      <span class="token function">updateChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> newCh<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>newCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 新虚拟节点有子节点，旧虚拟节点没有</span>      <span class="token comment">// 创建新虚拟节点的子节点，并更新到真实DOM上去</span>      <span class="token function">createEle</span><span class="token punctuation">(</span>newVnode<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 旧虚拟节点有子节点，新虚拟节点没有</span>      <span class="token comment">//直接删除真实DOM里对应的子节点</span>      api<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="updateChildren方法"><a href="#updateChildren方法" class="headerlink" title="updateChildren方法"></a>updateChildren方法</h3><p>新旧两个子节点集合以及其首尾指针为：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eb33b1b28e7461f9aedb857736a142c~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午2.55.26.png"></p><p>然后会进行互相进行比较，总共有五种比较情况：</p><ul><li>1、<code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li><li>2、<code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li><li>3、<code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li><li>4、<code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li><li>5、如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727b5dd8a3424d22afd9dc5cf0dae05e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午2.57.22.png"></p><h2 id="用index做key"><a href="#用index做key" class="headerlink" title="用index做key"></a>用index做key</h2><p>在进行子节点的 <code>diff算法</code> 过程中，会进行 旧首节点和新首节点的<code>sameNode</code>对比，这一步命中了逻辑，因为现在<code>新旧两次首部节点</code> 的 <code>key</code> 都是 <code>0</code>了，同理，key为1和2的也是命中了逻辑，导致<code>相同key的节点</code>会去进行<code>patchVnode</code>更新文本，而原本就有的<code>c节点</code>，却因为之前没有key为4的节点，而被当做了新节点，所以很搞笑，使用index做key，最后新增的居然是本来就已有的c节点。所以前三个都进行<code>patchVnode</code>更新文本，最后一个进行了<code>新增</code>，那就解释了为什么所有li标签都更新了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc93fb2bc544a83b8cc7b7cbcaf1857~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午5.45.17.png"></p><p>为什么用了id来当做key就实现了我们的理想效果呢，因为这么做的话，<code>a，b，c节点</code>的<code>key</code>就会是永远不变的，更新前后key都是一样的，并且又由于<code>a，b，c节点</code>的内容本来就没变，所以就算是进行了<code>patchVnode</code>，也不会执行里面复杂的更新操作，节省了性能，而林三心节点，由于更新前没有他的key所对应的节点，所以他被当做新的节点，增加到真实DOM上去了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833e0a795a3e4893a0c03bb78a63bffc~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 下午6.04.34.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是虚拟DOM&quot;&gt;&lt;a href=&quot;#什么是虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是虚拟DOM&quot;&gt;&lt;/a&gt;什么是虚拟DOM&lt;/h2&gt;&lt;p&gt;&lt;code&gt;虚拟DOM&lt;/code&gt;是一个&lt;code&gt;对象&lt;/code&gt;，一个什么样的对象呢</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="Vue进阶" scheme="http://example.com/categories/Vue/Vue%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>微任务、宏任务与Event-Loop</title>
    <link href="http://example.com/2022/02/22/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-Loop/"/>
    <id>http://example.com/2022/02/22/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8EEvent-Loop/</id>
    <published>2022-02-22T11:54:38.000Z</published>
    <updated>2022-02-22T13:13:59.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是宏任务与微任务？"><a href="#什么是宏任务与微任务？" class="headerlink" title="什么是宏任务与微任务？"></a>什么是宏任务与微任务？</h2><p>我们都知道 Js 是单线程都，但是一些高耗时操作就带来了进程阻塞问题。为了解决这个问题，Js 有两种任务的执行模式：<strong>同步模式（Synchronous）和异步模式（Asynchronous）</strong>。</p><p>在异步模式下，创建<strong>异步任务主要分为宏任务与微任务两种</strong>。ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。</p><h2 id="如何理解-script（整体代码块）是个宏任务呢"><a href="#如何理解-script（整体代码块）是个宏任务呢" class="headerlink" title="如何理解 script（整体代码块）是个宏任务呢"></a><strong>如何理解 script（整体代码块）是个宏任务呢</strong></h2><p>实际上如果同时存在两个 script 代码块，会首先在执行第一个 script 代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去清空微任务队列，再去开启第二个 script 代码块的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><h2 id="什么是-EventLoop-？"><a href="#什么是-EventLoop-？" class="headerlink" title="什么是 EventLoop ？"></a>什么是 EventLoop ？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baaf009636748c491898aafeceddb32~tplv-k3u1fbpfcp-watermark.awebp" alt="EventLoop.png"></p><p>因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 Js 解析完成后，在异步任务中，会先执行完所有的微任务，这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是宏任务与微任务？&quot;&gt;&lt;a href=&quot;#什么是宏任务与微任务？&quot; class=&quot;headerlink&quot; title=&quot;什么是宏任务与微任务？&quot;&gt;&lt;/a&gt;什么是宏任务与微任务？&lt;/h2&gt;&lt;p&gt;我们都知道 Js 是单线程都，但是一些高耗时操作就带来了进程阻塞问题</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://example.com/2022/02/22/Promise/"/>
    <id>http://example.com/2022/02/22/Promise/</id>
    <published>2022-02-22T10:05:58.000Z</published>
    <updated>2022-02-22T11:52:21.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Promise？我们用Promise来解决什么问题？"><a href="#什么是Promise？我们用Promise来解决什么问题？" class="headerlink" title="什么是Promise？我们用Promise来解决什么问题？"></a>什么是Promise？我们用Promise来解决什么问题？</h2><blockquote><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。 promise有三种状态：**pending(等待态)，fulfiled(成功态)，rejected(失败态)**；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。</p></blockquote><p>promise是用来解决两个问题的：</p><ul><li>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li><li>promise可以支持多个并发的请求，获取并发请求中的数据</li><li>这个promise可以解决异步的问题，本身不能说promise是异步的</li></ul><h2 id="es6-promise用法大全"><a href="#es6-promise用法大全" class="headerlink" title="es6 promise用法大全"></a>es6 promise用法大全</h2><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p><p>那就new一个</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//做一些异步操作</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'我是成功！！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：</p><ul><li>resolve ：异步操作执行成功后的回调函数</li><li>reject：异步操作执行失败后的回调函数</li></ul><h3 id="then-链式操作的用法"><a href="#then-链式操作的用法" class="headerlink" title="then 链式操作的用法"></a>then 链式操作的用法</h3><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法 :"></a>reject的用法 :</h3><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//做一些异步操作</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成1-10的随机数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'数字太大了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e1df3ec16ee~tplv-t2oaga2asx-watermark.awebp" alt="img">或者<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h3><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>somedata<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处的somedata未定义</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/1637880bdb32bee3~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try&#x2F;catch语句有相同的功能</p><h3 id="all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象"><a href="#all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象" class="headerlink" title="all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象"></a>all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象</h3><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。看下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> Promise1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> Promise3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise1<span class="token punctuation">,</span> Promise2<span class="token punctuation">,</span> Promise3<span class="token punctuation">]</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 三个都成功则成功  </span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 只要有失败，则失败 </span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据</p><h3 id="race的用法：谁跑的快，以谁为准执行回调"><a href="#race的用法：谁跑的快，以谁为准执行回调" class="headerlink" title="race的用法：谁跑的快，以谁为准执行回调"></a>race的用法：谁跑的快，以谁为准执行回调</h3><p>race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//请求某个图片资源</span>   <span class="token keyword">function</span> <span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>           <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token function">resolve</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'图片的路径'</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> p<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//延时函数，用于给请求计时</span>   <span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>           <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>               <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'图片请求超时'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> p<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span><span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requestImg函数会异步请求一张图片，我把地址写为”图片的路径”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16376a95ffa3b13c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Promise？我们用Promise来解决什么问题？&quot;&gt;&lt;a href=&quot;#什么是Promise？我们用Promise来解决什么问题？&quot; class=&quot;headerlink&quot; title=&quot;什么是Promise？我们用Promise来解决什么问题？&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="http://example.com/2022/02/21/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/02/21/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-21T06:47:05.000Z</published>
    <updated>2022-02-21T07:34:52.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="默认绑定规则"><a href="#默认绑定规则" class="headerlink" title="默认绑定规则"></a>默认绑定规则</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="隐式绑定规则"><a href="#隐式绑定规则" class="headerlink" title="隐式绑定规则"></a>隐式绑定规则</h2><p>谁调用就指向谁（隐式丢失 参数赋值）</p><h2 id="显式绑定规则"><a href="#显式绑定规则" class="headerlink" title="显式绑定规则"></a>显式绑定规则</h2><ul><li>call</li><li>apply</li><li>bind</li></ul><h2 id="new绑定规则"><a href="#new绑定规则" class="headerlink" title="new绑定规则"></a>new绑定规则</h2><p>实例化之后的对象</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数没有this指向，会向父级作用域查找</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;默认绑定规则&quot;&gt;&lt;a href=&quot;#默认绑定规则&quot; class=&quot;headerlink&quot; title=&quot;默认绑定规则&quot;&gt;&lt;/a&gt;默认绑定规则&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-js&quot; data-language=&quot;js&quot;&gt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>06 继承模式</title>
    <link href="http://example.com/2022/02/21/06%20%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/21/06%20%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-21T04:52:33.000Z</published>
    <updated>2022-02-21T05:44:59.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>套路</p><ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol><p>关键</p><ol><li>子类型的原型为父类型的一个实例对象</li></ol><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>套路:</p><ol><li><p>定义父类型构造函数</p></li><li><p>定义子类型构造函数</p></li><li><p>在子类型构造函数中调用父类型构造</p></li></ol><p>关键:</p><ol><li>在子类型构造函数中通用call()调用父类型构造函数</li></ol><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ul><li>原型链+借用构造函数的组合继承</li></ul><ol><li><p>利用原型链实现对父类型对象的方法继承</p></li><li><p>利用super()借用父类型构建函数初始化相同属性</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h2&gt;&lt;p&gt;套路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义父类型构造函数&lt;/li&gt;
&lt;li&gt;给父类型的原型添加方法&lt;/li&gt;
&lt;li&gt;定义</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>05 对象创建模式</title>
    <link href="http://example.com/2022/02/21/05%20%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/21/05%20%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-21T04:45:34.000Z</published>
    <updated>2022-02-21T05:44:46.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Object构造函数模式"><a href="#Object构造函数模式" class="headerlink" title="Object构造函数模式"></a>Object构造函数模式</h2><ul><li>套路: 先创建空Object对象, 再动态添加属性&#x2F;方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><h2 id="对象字面量模式"><a href="#对象字面量模式" class="headerlink" title="对象字面量模式"></a>对象字面量模式</h2><ul><li>套路: 使用{}创建对象, 同时指定属性&#x2F;方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型</li></ul><h2 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h2><ul><li>套路: 自定义构造函数, 通过new创建对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存</li></ul><h2 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h2><ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Object构造函数模式&quot;&gt;&lt;a href=&quot;#Object构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;Object构造函数模式&quot;&gt;&lt;/a&gt;Object构造函数模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;套路: 先创建空Object对象, 再动态添加属</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>03 作用域与作用域链</title>
    <link href="http://example.com/2022/02/21/03%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>http://example.com/2022/02/21/03%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</id>
    <published>2022-02-21T04:40:09.000Z</published>
    <updated>2022-02-21T05:43:55.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>就是一块”地盘”, 一个代码段所在的区域</li><li>它是静态的(相对于上下文对象), 在编写代码时就确定了</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>全局作用域</li><li>函数作用域</li><li>没有块作用域(ES6有了)</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>隔离变量，不同作用域下同名变量不会有冲突</li></ul><h2 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h2><h3 id="区别1"><a href="#区别1" class="headerlink" title="区别1"></a>区别1</h3><ul><li><p>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</p></li><li><p>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</p></li><li><p>函数执行上下文是在调用函数时, 函数体代码执行之前创建</p><h3 id="区别2"><a href="#区别2" class="headerlink" title="区别2"></a>区别2</h3></li><li><p>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</p></li><li><p>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3></li><li><p>执行上下文(对象)是从属于所在的作用域</p></li><li><p>全局上下文环境&#x3D;&#x3D;&gt;全局作用域</p></li><li><p>函数上下文环境&#x3D;&#x3D;&gt;对应的函数使用域</p></li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><ul><li><p>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</p></li><li><p>查找变量时就是沿着作用域链来查找的</p><h3 id="查找一个变量的查找规则"><a href="#查找一个变量的查找规则" class="headerlink" title="查找一个变量的查找规则"></a>查找一个变量的查找规则</h3></li><li><p>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</p></li><li><p>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</p></li><li><p>再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;h3 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h3&gt;&lt;u</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>02 执行上下文与执行上下文栈</title>
    <link href="http://example.com/2022/02/21/02%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <id>http://example.com/2022/02/21/02%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</id>
    <published>2022-02-21T04:12:22.000Z</published>
    <updated>2022-02-21T05:43:17.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><ul><li>通过var定义(声明)的变量, 在定义语句之前就可以访问到</li><li>值: undefined</li></ul><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><ul><li>通过function声明的函数, 在之前就可以直接调用</li><li>值: 函数定义(对象)</li></ul><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="代码分类-位置"><a href="#代码分类-位置" class="headerlink" title="代码分类(位置)"></a>代码分类(位置)</h3><ul><li>全局代码</li><li>函数(局部)代码</li></ul><h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><ul><li><p>在执行全局代码前将window确定为全局执行上下文</p></li><li><p>对全局数据进行预处理</p><ul><li>var定义的全局变量&#x3D;&#x3D;&gt;undefined, 添加为window的属性</li><li>function声明的全局函数&#x3D;&#x3D;&gt;赋值(fun), 添加为window的方法</li><li>this&#x3D;&#x3D;&gt;赋值(window)</li></ul></li><li><p>开始执行全局代码</p><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3></li><li><p>在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)</p></li><li><p>对局部数据进行预处理</p><ul><li>形参变量&#x3D;&#x3D;&gt; 赋值(实参) &#x3D;&#x3D;&gt;添加为执行上下文的属性</li><li>arguments&#x3D;&#x3D;&gt;赋值(实参列表), 添加为执行上下文的属性</li><li>var定义的局部变量&#x3D;&#x3D;&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 &#x3D;&#x3D;&gt;赋值(fun), 添加为执行上下文的方法</li><li>this&#x3D;&#x3D;&gt;赋值(调用函数的对象)</li></ul></li><li><p>开始执行函数体代码</p></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><ol><li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li><li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li><li>在当前函数执行完后,将栈顶的对象移除(出栈)</li><li>当所有的代码执行完后, 栈中只剩下window</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量提升与函数提升&quot;&gt;&lt;a href=&quot;#变量提升与函数提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升与函数提升&quot;&gt;&lt;/a&gt;变量提升与函数提升&lt;/h2&gt;&lt;h3 id=&quot;变量声明提升&quot;&gt;&lt;a href=&quot;#变量声明提升&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>01 原型与原型链</title>
    <link href="http://example.com/2022/02/20/01%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://example.com/2022/02/20/01%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2022-02-20T14:53:37.000Z</published>
    <updated>2022-02-22T04:40:33.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h3><ul><li><p>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</p></li><li><p>原型对象中有一个属性constructor, 它指向函数对象</p><h3 id="给原型对象添加属性-一般都是方法"><a href="#给原型对象添加属性-一般都是方法" class="headerlink" title="给原型对象添加属性(一般都是方法)"></a>给原型对象添加属性(一般都是方法)</h3></li><li><p>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</p></li></ul><h2 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h2><ol><li>每个函数function都有一个prototype，即显式原型(属性)</li><li>每个实例对象都有一个__  proto __，可称为隐式原型(属性)</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象</li><li>对象的__ proto __属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值</li><li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>访问一个对象的属性时，<ul><li>先在自身属性中查找，找到返回</li><li>如果没有, 再沿着__ proto __这条链向上查找, 找到返回</li><li>如果最终没找到, 返回undefined</li></ul></li><li>别名: 隐式原型链</li><li>作用: 查找对象的属性(方法)</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s3.bmp.ovh/imgs/2022/02/c858a349ff515f66.png"></p><h3 id="instanceof是如何判断的"><a href="#instanceof是如何判断的" class="headerlink" title="instanceof是如何判断的?"></a>instanceof是如何判断的?</h3><ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;h3 id=&quot;函数的prototype属性&quot;&gt;&lt;a href=&quot;#函数的prototype属性&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>04 闭包</title>
    <link href="http://example.com/2022/02/20/04%20%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2022/02/20/04%20%E9%97%AD%E5%8C%85/</id>
    <published>2022-02-20T14:44:07.000Z</published>
    <updated>2022-02-22T00:08:38.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="如何产生闭包"><a href="#如何产生闭包" class="headerlink" title="如何产生闭包"></a>如何产生闭包</h3><p>当一个嵌套的内部函数（子）引用了嵌套的外部（父）的函数的变量（函数）时 就产生了闭包</p><h3 id="闭包到底是什么"><a href="#闭包到底是什么" class="headerlink" title="闭包到底是什么"></a>闭包到底是什么</h3><ul><li><p>闭包时嵌套的内部函数</p></li><li><p>包含被引用变量（函数）的对象</p></li><li><p>闭包存在于嵌套的内部函数中</p></li></ul><h3 id="产生闭包的条件"><a href="#产生闭包的条件" class="headerlink" title="产生闭包的条件"></a>产生闭包的条件</h3><ol><li>函数嵌套</li><li>内部函数引用了外部函数的数据</li></ol><hr><h2 id="常见闭包"><a href="#常见闭包" class="headerlink" title="常见闭包"></a>常见闭包</h2><ol><li><p>将函数作为另一个函数的返回值</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将函数作为实参传递给另一个参数调用</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li><p>使用函数内部的变量在函数执行完后 仍然存活在内存中（延长了局部变量的生命周期）</p></li><li><p>让函数外部可以操作到函数内部的数据</p><blockquote><p>比喻成遥控器，函数内部有很多东西，但是在外部只能通过遥控器使用暴露出来的方法 比如在内部定义了音量，如果拿着遥控器能乱改就出了大问题，比如让音量是负的，程序就出错了 于是我通过闭包的方法，能访问到音量，也能进行一些有局限性的操作 于是给外部（遥控器）上暴露了一个方法（按钮），调用一次（按下按钮），就音量加1，而无法产生其他不可控的结果</p></blockquote></li></ol><hr><h2 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h2><ul><li>产生：在嵌套内部函数定义执行完时就长生了</li><li>死亡：在嵌套的内部函数称为垃圾对象时</li></ul><h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><ul><li>函数执行完后 函数内的局部变量没有释放 占用内存时间会变长</li><li>容易造成内存泄漏</li></ul><hr><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><ol><li><p>内存溢出</p><ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时 就抛出内存的错误</li></ul></li><li><p>内存泄漏</p><ul><li>占用的内存没有及时释放</li><li>内存泄漏累积多了导致内存溢出</li><li>常见的内存泄漏<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;h3 id=&quot;如何产生闭包&quot;&gt;&lt;a href=&quot;#如何产生闭包&quot; class=&quot;headerlink&quot; title=&quot;如何产生闭包&quot;&gt;&lt;/a&gt;如</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="JS高级" scheme="http://example.com/categories/JavaScript/JS%E9%AB%98%E7%BA%A7/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="http://example.com/2022/02/20/ES6/"/>
    <id>http://example.com/2022/02/20/ES6/</id>
    <published>2022-02-20T13:59:45.000Z</published>
    <updated>2022-02-20T14:23:12.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li><strong>const命令</strong>：声明常量</li><li><strong>let命令</strong>：声明变量</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>作用域<ul><li><strong>全局作用域</strong></li><li><strong>函数作用域</strong>：<code>function() &#123;&#125;</code></li><li><strong>块级作用域</strong>：<code>&#123;&#125;</code></li></ul></li><li>作用范围<ul><li><code>var命令</code>在全局代码中执行</li><li><code>const命令</code>和<code>let命令</code>只能在代码块中执行</li></ul></li><li>赋值使用<ul><li><code>const命令</code>声明常量后必须立马赋值</li><li><code>let命令</code>声明变量后可立马赋值或使用时赋值</li></ul></li><li>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></li></ul><h3 id="重点难点"><a href="#重点难点" class="headerlink" title="重点难点"></a>重点难点</h3><ul><li>不允许重复声明</li><li>未定义就使用会报错：<code>const命令</code>和<code>let命令</code>不存在变量提升</li><li>暂时性死区：在代码块内使用<code>const命令</code>和<code>let命令</code>声明变量之前，该变量都不可用</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li><strong>字符串解构</strong>：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li><strong>数值解构</strong>：<code>const &#123; toString: s &#125; = 123</code></li><li><strong>布尔解构</strong>：<code>const &#123; toString: b &#125; = true</code></li><li><strong>对象解构</strong></li><li>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li><li><strong>数组解构</strong></li><li>规则：数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式：<code>const [x, y] = [1, 2]</code></li><li>默认：<code>const [x, y = 2] = [1]</code></li><li><strong>函数参数解构</strong></li><li>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>交换变量值：<code>[x, y] = [y, x]</code></li><li>返回函数多个值：<code>const [x, y, z] = Func()</code></li><li>定义函数参数：<code>Func([1, 2])</code></li><li>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li><li>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li><li>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><h3 id="重点难点-1"><a href="#重点难点-1" class="headerlink" title="重点难点"></a>重点难点</h3><ul><li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li><li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>解构默认值生效条件：属性值严格等于<code>undefined</code></li><li>解构遵循匹配模式</li><li>解构不成功时变量的值等于<code>undefined</code></li><li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li>命令<ul><li>export：规定模块对外接口<ul><li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li><li><strong>单独导出</strong>：<code>export const name = &quot;Bruce&quot;</code></li><li><strong>按需导出</strong>：<code>export &#123; age, name, sex &#125;</code>(推荐)</li><li><strong>改名导出</strong>：<code>export &#123; name as newName &#125;</code></li></ul></li><li>import：导入模块内部功能<ul><li><strong>默认导入</strong>：<code>import Person from &quot;person&quot;</code></li><li><strong>整体导入</strong>：<code>import * as Person from &quot;person&quot;</code></li><li><strong>按需导入</strong>：<code>import &#123; age, name, sex &#125; from &quot;person&quot;</code></li><li><strong>改名导入</strong>：<code>import &#123; name as newName &#125; from &quot;person&quot;</code></li><li><strong>自执导入</strong>：<code>import &quot;person&quot;</code></li><li><strong>复合导入</strong>：<code>import Person, &#123; name &#125; from &quot;person&quot;</code></li></ul></li></ul></li><li>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</li><li>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li><li>严格模式：ES6模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</li></ul><h3 id="重点难点-2"><a href="#重点难点-2" class="headerlink" title="重点难点"></a>重点难点</h3><ul><li>ES6模块中，顶层<code>this</code>指向<code>undefined</code>，不应该在顶层代码使用<code>this</code></li><li>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</li><li><code>export命令</code>输出的接口与其对应的值是<code>动态绑定关系</code>，即通过该接口可获取模块内部实时的值</li><li><code>import命令</code>大括号里的变量名必须与被导入模块对外接口的名称相同</li><li><code>import命令</code>输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</li><li><code>import命令</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li><li>重复执行同一句<code>import语句</code>，只会执行一次</li><li><code>export default</code>命令只能使用一次</li><li><code>export default命令</code>导出的整体模块，在执行<code>import命令</code>时其后不能跟<code>大括号</code></li><li><code>export default命令</code>本质是输出一个名为<code>default</code>的变量，后面不能跟<code>变量声明语句</code></li><li><code>export default命令</code>本质是将后面的值赋给名为<code>default</code>的变量，可直接将值写在其后</li><li><code>export default命令</code>和<code>export &#123;&#125;命令</code>可同时存在，对应<code>复合导入</code></li><li><code>export命令</code>和<code>import命令</code>可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</li><li><code>import()</code>加载模块成功后，此模块会作为一个对象，当作<code>then()</code>的参数，可使用<code>对象解构赋值</code>来获取输出接口</li><li>同时动态加载多个模块时，可使用<code>Promise.all()</code>和<code>import()</code>相结合来实现</li><li><code>import()</code>和结合<code>async/await</code>来书写同步操作的代码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;const命令&lt;/strong&gt;：声明常量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;let命令&lt;/strong&gt;：声明</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/categories/JavaScript/ES6/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
</feed>
